<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Geocomputation with R</title>
  <meta name="description" content="Forthcoming book on geographic data with R.">
  <meta name="generator" content="bookdown 0.5 and GitBook 2.6.7">

  <meta property="og:title" content="Geocomputation with R" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="http://robinlovelace.net/geocompr" />
  
  <meta property="og:description" content="Forthcoming book on geographic data with R." />
  <meta name="github-repo" content="Robinlovelace/geocompr" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Geocomputation with R" />
  
  <meta name="twitter:description" content="Forthcoming book on geographic data with R." />
  

<meta name="author" content="Robin Lovelace, Jakub Nowosad, Jannes Muenchow">


<meta name="date" content="2017-12-03">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="spatial-operations.html">
<link rel="next" href="read-write.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<script src="libs/htmlwidgets-0.9/htmlwidgets.js"></script>
<link href="libs/leaflet-0.7.7/leaflet.css" rel="stylesheet" />
<script src="libs/leaflet-0.7.7/leaflet.js"></script>
<link href="libs/leafletfix-1.0.0/leafletfix.css" rel="stylesheet" />
<link href="libs/leaflet-label-0.2.2/leaflet.label.css" rel="stylesheet" />
<script src="libs/leaflet-label-0.2.2/leaflet.label.js"></script>
<script src="libs/Proj4Leaflet-0.7.2/proj4-compressed.js"></script>
<script src="libs/Proj4Leaflet-0.7.2/proj4leaflet.js"></script>
<script src="libs/leaflet-binding-1.1.0/leaflet.js"></script>
<script src="libs/leaflet-providers-1.0.27/leaflet-providers.js"></script>
<script src="libs/leaflet-providers-plugin-1.1.0/leaflet-providers-plugin.js"></script>
<link href="libs/leaflet-awesomemarkers-2.0.3/leaflet.awesome-markers.css" rel="stylesheet" />
<script src="libs/leaflet-awesomemarkers-2.0.3/leaflet.awesome-markers.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-99618359-1', 'auto');
  ga('send', 'pageview');

</script>


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="css/style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Geocomputation with R</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Welcome</a><ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#development"><i class="fa fa-check"></i>Development</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#how-to-contribute"><i class="fa fa-check"></i>How to contribute?</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#reproducibility"><i class="fa fa-check"></i>Reproducibility</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="preface.html"><a href="preface.html"><i class="fa fa-check"></i>Preface</a></li>
<li class="part"><span><b>I Foundations</b></span></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul>
<li class="chapter" data-level="1.1" data-path="intro.html"><a href="intro.html#what-is-geocomputation"><i class="fa fa-check"></i><b>1.1</b> What is geocomputation?</a></li>
<li class="chapter" data-level="1.2" data-path="intro.html"><a href="intro.html#why-geocomputation-with-r"><i class="fa fa-check"></i><b>1.2</b> Why Geocomputation with R?</a></li>
<li class="chapter" data-level="1.3" data-path="intro.html"><a href="intro.html#software-for-geocomputation"><i class="fa fa-check"></i><b>1.3</b> Software for geocomputation</a></li>
<li class="chapter" data-level="1.4" data-path="intro.html"><a href="intro.html#rs-spatial-ecosystem"><i class="fa fa-check"></i><b>1.4</b> R’s spatial ecosystem</a></li>
<li class="chapter" data-level="1.5" data-path="intro.html"><a href="intro.html#the-history-of-r-spatial"><i class="fa fa-check"></i><b>1.5</b> The history of R-spatial</a></li>
<li class="chapter" data-level="1.6" data-path="intro.html"><a href="intro.html#exercises"><i class="fa fa-check"></i><b>1.6</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="spatial-class.html"><a href="spatial-class.html"><i class="fa fa-check"></i><b>2</b> Geographic data in R</a><ul>
<li class="chapter" data-level="" data-path="spatial-class.html"><a href="spatial-class.html#prerequisites"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="2.1" data-path="spatial-class.html"><a href="spatial-class.html#vector-data"><i class="fa fa-check"></i><b>2.1</b> Vector data</a><ul>
<li class="chapter" data-level="2.1.1" data-path="spatial-class.html"><a href="spatial-class.html#intro-sf"><i class="fa fa-check"></i><b>2.1.1</b> An introduction to simple features</a></li>
<li class="chapter" data-level="2.1.2" data-path="spatial-class.html"><a href="spatial-class.html#why-simple-features"><i class="fa fa-check"></i><b>2.1.2</b> Why simple features?</a></li>
<li class="chapter" data-level="2.1.3" data-path="spatial-class.html"><a href="spatial-class.html#basic-map"><i class="fa fa-check"></i><b>2.1.3</b> Basic map making</a></li>
<li class="chapter" data-level="2.1.4" data-path="spatial-class.html"><a href="spatial-class.html#base-args"><i class="fa fa-check"></i><b>2.1.4</b> Base plot arguments</a></li>
<li class="chapter" data-level="2.1.5" data-path="spatial-class.html"><a href="spatial-class.html#sf-classes"><i class="fa fa-check"></i><b>2.1.5</b> Simple feature classes</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="spatial-class.html"><a href="spatial-class.html#raster-data"><i class="fa fa-check"></i><b>2.2</b> Raster data</a><ul>
<li class="chapter" data-level="2.2.1" data-path="spatial-class.html"><a href="spatial-class.html#an-introduction-to-raster"><i class="fa fa-check"></i><b>2.2.1</b> An introduction to raster</a></li>
<li class="chapter" data-level="2.2.2" data-path="spatial-class.html"><a href="spatial-class.html#basic-map-making"><i class="fa fa-check"></i><b>2.2.2</b> Basic map making</a></li>
<li class="chapter" data-level="2.2.3" data-path="spatial-class.html"><a href="spatial-class.html#raster-classes"><i class="fa fa-check"></i><b>2.2.3</b> Raster classes</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="spatial-class.html"><a href="spatial-class.html#crs-intro"><i class="fa fa-check"></i><b>2.3</b> Coordinate Reference Systems</a><ul>
<li class="chapter" data-level="2.3.1" data-path="spatial-class.html"><a href="spatial-class.html#geographic-coordinate-systems"><i class="fa fa-check"></i><b>2.3.1</b> Geographic coordinate systems</a></li>
<li class="chapter" data-level="2.3.2" data-path="spatial-class.html"><a href="spatial-class.html#projected-coordinate-systems"><i class="fa fa-check"></i><b>2.3.2</b> Projected coordinate systems</a></li>
<li class="chapter" data-level="2.3.3" data-path="spatial-class.html"><a href="spatial-class.html#crs-in-r"><i class="fa fa-check"></i><b>2.3.3</b> CRS in R</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="spatial-class.html"><a href="spatial-class.html#units"><i class="fa fa-check"></i><b>2.4</b> Units</a></li>
<li class="chapter" data-level="2.5" data-path="spatial-class.html"><a href="spatial-class.html#ex2"><i class="fa fa-check"></i><b>2.5</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="attr.html"><a href="attr.html"><i class="fa fa-check"></i><b>3</b> Attribute operations</a><ul>
<li class="chapter" data-level="" data-path="attr.html"><a href="attr.html#prerequisites-1"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="3.1" data-path="attr.html"><a href="attr.html#introduction"><i class="fa fa-check"></i><b>3.1</b> Introduction</a></li>
<li class="chapter" data-level="3.2" data-path="attr.html"><a href="attr.html#vector-attribute-manipulation"><i class="fa fa-check"></i><b>3.2</b> Vector attribute manipulation</a><ul>
<li class="chapter" data-level="3.2.1" data-path="attr.html"><a href="attr.html#vector-attribute-subsetting"><i class="fa fa-check"></i><b>3.2.1</b> Vector attribute subsetting</a></li>
<li class="chapter" data-level="3.2.2" data-path="attr.html"><a href="attr.html#vector-attribute-aggregation"><i class="fa fa-check"></i><b>3.2.2</b> Vector attribute aggregation</a></li>
<li class="chapter" data-level="3.2.3" data-path="attr.html"><a href="attr.html#vector-attribute-joining"><i class="fa fa-check"></i><b>3.2.3</b> Vector attribute joining</a></li>
<li class="chapter" data-level="3.2.4" data-path="attr.html"><a href="attr.html#vec-attr-creation"><i class="fa fa-check"></i><b>3.2.4</b> Creating attributes and removing spatial information</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="attr.html"><a href="attr.html#manipulating-raster-objects"><i class="fa fa-check"></i><b>3.3</b> Manipulating raster objects</a><ul>
<li class="chapter" data-level="3.3.1" data-path="attr.html"><a href="attr.html#raster-subsetting"><i class="fa fa-check"></i><b>3.3.1</b> Raster subsetting</a></li>
<li class="chapter" data-level="3.3.2" data-path="attr.html"><a href="attr.html#summarizing-raster-objects"><i class="fa fa-check"></i><b>3.3.2</b> Summarizing raster objects</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="attr.html"><a href="attr.html#exercises-1"><i class="fa fa-check"></i><b>3.4</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="spatial-operations.html"><a href="spatial-operations.html"><i class="fa fa-check"></i><b>4</b> Spatial operations</a><ul>
<li class="chapter" data-level="" data-path="spatial-operations.html"><a href="spatial-operations.html#prerequisites-2"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="4.1" data-path="spatial-operations.html"><a href="spatial-operations.html#introduction-1"><i class="fa fa-check"></i><b>4.1</b> Introduction</a></li>
<li class="chapter" data-level="4.2" data-path="spatial-operations.html"><a href="spatial-operations.html#spatial-operations-on-vector-data"><i class="fa fa-check"></i><b>4.2</b> Spatial operations on vector data</a><ul>
<li class="chapter" data-level="4.2.1" data-path="spatial-operations.html"><a href="spatial-operations.html#spatial-subsetting"><i class="fa fa-check"></i><b>4.2.1</b> Spatial subsetting</a></li>
<li class="chapter" data-level="4.2.2" data-path="spatial-operations.html"><a href="spatial-operations.html#topological-relations"><i class="fa fa-check"></i><b>4.2.2</b> Topological relations</a></li>
<li class="chapter" data-level="4.2.3" data-path="spatial-operations.html"><a href="spatial-operations.html#spatial-joining"><i class="fa fa-check"></i><b>4.2.3</b> Spatial joining</a></li>
<li class="chapter" data-level="4.2.4" data-path="spatial-operations.html"><a href="spatial-operations.html#non-overlapping-joins"><i class="fa fa-check"></i><b>4.2.4</b> Non-overlapping joins</a></li>
<li class="chapter" data-level="4.2.5" data-path="spatial-operations.html"><a href="spatial-operations.html#spatial-data-aggregation"><i class="fa fa-check"></i><b>4.2.5</b> Spatial data aggregation</a></li>
<li class="chapter" data-level="4.2.6" data-path="spatial-operations.html"><a href="spatial-operations.html#distance-relations"><i class="fa fa-check"></i><b>4.2.6</b> Distance relations</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="spatial-operations.html"><a href="spatial-operations.html#spatial-operations-on-raster-data"><i class="fa fa-check"></i><b>4.3</b> Spatial operations on raster data</a><ul>
<li class="chapter" data-level="4.3.1" data-path="attr.html"><a href="attr.html#raster-subsetting"><i class="fa fa-check"></i><b>4.3.1</b> Spatial subsetting</a></li>
<li class="chapter" data-level="4.3.2" data-path="spatial-operations.html"><a href="spatial-operations.html#map-algebra"><i class="fa fa-check"></i><b>4.3.2</b> Map algebra</a></li>
<li class="chapter" data-level="4.3.3" data-path="spatial-operations.html"><a href="spatial-operations.html#local-operations"><i class="fa fa-check"></i><b>4.3.3</b> Local operations</a></li>
<li class="chapter" data-level="4.3.4" data-path="spatial-operations.html"><a href="spatial-operations.html#focal-operations"><i class="fa fa-check"></i><b>4.3.4</b> Focal operations</a></li>
<li class="chapter" data-level="4.3.5" data-path="spatial-operations.html"><a href="spatial-operations.html#zonal-operations"><i class="fa fa-check"></i><b>4.3.5</b> Zonal operations</a></li>
<li class="chapter" data-level="4.3.6" data-path="spatial-operations.html"><a href="spatial-operations.html#global-operations-and-distances"><i class="fa fa-check"></i><b>4.3.6</b> Global operations and distances</a></li>
<li class="chapter" data-level="4.3.7" data-path="spatial-operations.html"><a href="spatial-operations.html#merging-rasters"><i class="fa fa-check"></i><b>4.3.7</b> Merging rasters</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="spatial-operations.html"><a href="spatial-operations.html#exercises-2"><i class="fa fa-check"></i><b>4.4</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="transform.html"><a href="transform.html"><i class="fa fa-check"></i><b>5</b> Geometric operations</a><ul>
<li class="chapter" data-level="" data-path="transform.html"><a href="transform.html#prerequisites-3"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="5.1" data-path="transform.html"><a href="transform.html#reprojecting-geographic-data"><i class="fa fa-check"></i><b>5.1</b> Reprojecting geographic data</a><ul>
<li class="chapter" data-level="5.1.1" data-path="transform.html"><a href="transform.html#reprojecting-vector-geometries"><i class="fa fa-check"></i><b>5.1.1</b> Reprojecting vector geometries</a></li>
<li class="chapter" data-level="5.1.2" data-path="transform.html"><a href="transform.html#reprojecting-raster-geometries"><i class="fa fa-check"></i><b>5.1.2</b> Reprojecting raster geometries</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="transform.html"><a href="transform.html#geo-vec"><i class="fa fa-check"></i><b>5.2</b> Geometric operations on vector data</a><ul>
<li class="chapter" data-level="5.2.1" data-path="transform.html"><a href="transform.html#geometry-unions"><i class="fa fa-check"></i><b>5.2.1</b> Geometry unions</a></li>
<li class="chapter" data-level="5.2.2" data-path="transform.html"><a href="transform.html#clipping"><i class="fa fa-check"></i><b>5.2.2</b> Clipping</a></li>
<li class="chapter" data-level="5.2.3" data-path="transform.html"><a href="transform.html#centroids"><i class="fa fa-check"></i><b>5.2.3</b> Centroids</a></li>
<li class="chapter" data-level="5.2.4" data-path="transform.html"><a href="transform.html#buffers"><i class="fa fa-check"></i><b>5.2.4</b> Buffers</a></li>
<li class="chapter" data-level="5.2.5" data-path="transform.html"><a href="transform.html#affine-transformations"><i class="fa fa-check"></i><b>5.2.5</b> Affine transformations</a></li>
<li class="chapter" data-level="5.2.6" data-path="transform.html"><a href="transform.html#type-transformation"><i class="fa fa-check"></i><b>5.2.6</b> Type transformation</a></li>
<li class="chapter" data-level="5.2.7" data-path="transform.html"><a href="transform.html#simplification"><i class="fa fa-check"></i><b>5.2.7</b> Simplification</a></li>
<li class="chapter" data-level="5.2.8" data-path="transform.html"><a href="transform.html#rasterization"><i class="fa fa-check"></i><b>5.2.8</b> Rasterization</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="transform.html"><a href="transform.html#geo-ras"><i class="fa fa-check"></i><b>5.3</b> Geometric operations on raster data</a><ul>
<li class="chapter" data-level="5.3.1" data-path="transform.html"><a href="transform.html#raster-alignment"><i class="fa fa-check"></i><b>5.3.1</b> Raster alignment</a></li>
<li class="chapter" data-level="5.3.2" data-path="transform.html"><a href="transform.html#ras-agg"><i class="fa fa-check"></i><b>5.3.2</b> Aggregation</a></li>
<li class="chapter" data-level="5.3.3" data-path="transform.html"><a href="transform.html#vectorization"><i class="fa fa-check"></i><b>5.3.3</b> Vectorization</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="transform.html"><a href="transform.html#exercises-3"><i class="fa fa-check"></i><b>5.4</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="read-write.html"><a href="read-write.html"><i class="fa fa-check"></i><b>6</b> Geographic data I/O</a><ul>
<li class="chapter" data-level="" data-path="read-write.html"><a href="read-write.html#prerequisites-4"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="6.1" data-path="read-write.html"><a href="read-write.html#introduction-2"><i class="fa fa-check"></i><b>6.1</b> Introduction</a></li>
<li class="chapter" data-level="6.2" data-path="read-write.html"><a href="read-write.html#retrieving-data"><i class="fa fa-check"></i><b>6.2</b> Retrieving open data</a></li>
<li class="chapter" data-level="6.3" data-path="read-write.html"><a href="read-write.html#file-formats"><i class="fa fa-check"></i><b>6.3</b> File formats</a></li>
<li class="chapter" data-level="6.4" data-path="read-write.html"><a href="read-write.html#data-input"><i class="fa fa-check"></i><b>6.4</b> Data Input (I)</a><ul>
<li class="chapter" data-level="6.4.1" data-path="read-write.html"><a href="read-write.html#vector-data-1"><i class="fa fa-check"></i><b>6.4.1</b> Vector data</a></li>
<li class="chapter" data-level="6.4.2" data-path="read-write.html"><a href="read-write.html#raster-data-1"><i class="fa fa-check"></i><b>6.4.2</b> Raster data</a></li>
</ul></li>
<li class="chapter" data-level="6.5" data-path="read-write.html"><a href="read-write.html#data-output"><i class="fa fa-check"></i><b>6.5</b> Data output (O)</a><ul>
<li class="chapter" data-level="6.5.1" data-path="read-write.html"><a href="read-write.html#vector-data-2"><i class="fa fa-check"></i><b>6.5.1</b> Vector data</a></li>
<li class="chapter" data-level="6.5.2" data-path="read-write.html"><a href="read-write.html#raster-data-2"><i class="fa fa-check"></i><b>6.5.2</b> Raster data</a></li>
</ul></li>
<li class="chapter" data-level="6.6" data-path="read-write.html"><a href="read-write.html#visual-outputs"><i class="fa fa-check"></i><b>6.6</b> Visual outputs</a></li>
<li class="chapter" data-level="6.7" data-path="read-write.html"><a href="read-write.html#exercises-4"><i class="fa fa-check"></i><b>6.7</b> Exercises</a></li>
</ul></li>
<li class="part"><span><b>II Basic applications</b></span></li>
<li class="chapter" data-level="7" data-path="location.html"><a href="location.html"><i class="fa fa-check"></i><b>7</b> Location analysis</a><ul>
<li class="chapter" data-level="" data-path="location.html"><a href="location.html#prerequisites-5"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="7.1" data-path="location.html"><a href="location.html#introduction-3"><i class="fa fa-check"></i><b>7.1</b> Introduction</a></li>
<li class="chapter" data-level="7.2" data-path="location.html"><a href="location.html#case-study"><i class="fa fa-check"></i><b>7.2</b> Case study</a><ul>
<li class="chapter" data-level="7.2.1" data-path="location.html"><a href="location.html#create-census-rasters"><i class="fa fa-check"></i><b>7.2.1</b> Create census rasters</a></li>
<li class="chapter" data-level="7.2.2" data-path="location.html"><a href="location.html#define-metropolitan-areas"><i class="fa fa-check"></i><b>7.2.2</b> Define metropolitan areas</a></li>
<li class="chapter" data-level="7.2.3" data-path="location.html"><a href="location.html#points-of-interest"><i class="fa fa-check"></i><b>7.2.3</b> Points of interest</a></li>
<li class="chapter" data-level="7.2.4" data-path="location.html"><a href="location.html#identifying-suitable-locations"><i class="fa fa-check"></i><b>7.2.4</b> Identifying suitable locations</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="location.html"><a href="location.html#discussion-and-next-steps"><i class="fa fa-check"></i><b>7.3</b> Discussion and next steps</a></li>
<li class="chapter" data-level="7.4" data-path="location.html"><a href="location.html#exercises-5"><i class="fa fa-check"></i><b>7.4</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="transport-applications.html"><a href="transport-applications.html"><i class="fa fa-check"></i><b>8</b> Transport applications</a><ul>
<li class="chapter" data-level="" data-path="transport-applications.html"><a href="transport-applications.html#prerequisites-6"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="8.1" data-path="transport-applications.html"><a href="transport-applications.html#input-data-a-case-study-of-bristol"><i class="fa fa-check"></i><b>8.1</b> Input data: a case study of Bristol</a></li>
<li class="chapter" data-level="8.2" data-path="transport-applications.html"><a href="transport-applications.html#transport-zones"><i class="fa fa-check"></i><b>8.2</b> Transport zones</a></li>
<li class="chapter" data-level="8.3" data-path="transport-applications.html"><a href="transport-applications.html#nodes-on-the-transport-system"><i class="fa fa-check"></i><b>8.3</b> Nodes on the transport system</a></li>
<li class="chapter" data-level="8.4" data-path="transport-applications.html"><a href="transport-applications.html#desire-line-analysis"><i class="fa fa-check"></i><b>8.4</b> Desire line analysis</a></li>
<li class="chapter" data-level="8.5" data-path="transport-applications.html"><a href="transport-applications.html#route-analysis"><i class="fa fa-check"></i><b>8.5</b> Route analysis</a></li>
<li class="chapter" data-level="8.6" data-path="transport-applications.html"><a href="transport-applications.html#route-networks"><i class="fa fa-check"></i><b>8.6</b> Route networks</a></li>
<li class="chapter" data-level="8.7" data-path="transport-applications.html"><a href="transport-applications.html#agents-in-the-transport-system"><i class="fa fa-check"></i><b>8.7</b> Agents in the transport system</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="http://robinlovelace.net/">Robin Lovelace</a></li>
<li><a href="https://nowosad.github.io/">Jakub Nowosad</a></li>
<li><a href="http://www.geographie.uni-jena.de/en/Muenchow.html">Jannes Muenchow</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Geocomputation with R</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="transform" class="section level1">
<h1><span class="header-section-number">5</span> Geometric operations</h1>
<div id="prerequisites-3" class="section level2 unnumbered">
<h2>Prerequisites</h2>
<ul>
<li>This chapter requires the following packages:<a href="#fn21" class="footnoteRef" id="fnref21"><sup>21</sup></a></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(sf)
<span class="kw">library</span>(raster)
<span class="kw">library</span>(tidyverse)</code></pre></div>
<ul>
<li>It also relies on <strong>spData</strong> and <strong>spDataLarge</strong>, which load <code>cycle_hire_osm</code> dataset and provide external files:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(spData)
<span class="kw">library</span>(spDataLarge)</code></pre></div>
<p>The previous three chapters have demonstrated how geographic datasets are structured in R (Chapter <a href="spatial-class.html#spatial-class">2</a>) and how to manipulate them based on their non-geographic attributes (<a href="attr.html#attr">3</a>) and spatial properties (<a href="#spatial-data-operations"><strong>??</strong></a>). This chapter goes a step further, by showing how to modify the <em>geometry</em> underlying spatial datasets.</p>
<p>Section <a href="transform.html#geo-vec">5.2</a> covers transforming vector geometries. This includes simplifying, buffering, clipping and even shifting/scaling/rotating geometries using ‘affine transformations’. Geometry unions, which underlie spatial data aggregation, are covered in section <a href="transform.html#geometry-unions">5.2.1</a>. Advanced transformations of vector geometries include type transformations (e.g. from few multipolygons to many polygons) and ‘rasterization’, which sets-up the next section.</p>
<p>Section <a href="transform.html#geo-ras">5.3</a> covers geometric transformations on raster objects. This involves changing the size and number of the underlying pixels, and assigning them new values. It teaches how to change the resolution (also called raster aggregation and disaggregation), the extent and the origin of a raster. These operations are especially useful if one would like to align raster datasets from diverse sources (see section <a href="transform.html#raster-alignment">5.3.1</a>). Only making sure that these rasters share the same header information allows the jointly usage of map algebra operations (see section <a href="spatial-operations.html#map-algebra">4.3.2</a>).</p>
<p>A vital type of geometry transformation is <em>reprojecting</em> from one coordinate reference system (CRS) to another. Because of the importance of reprojection, introduced in Chapter <a href="spatial-class.html#spatial-class">2</a> (see figure <a href="spatial-class.html#fig:vectorplots">2.1</a> and section <a href="spatial-class.html#crs-intro">2.3</a>), and the fact that it applies to raster and vector geometries alike, it is the topic of the first section in this chapter.</p>
</div>
<div id="reprojecting-geographic-data" class="section level2">
<h2><span class="header-section-number">5.1</span> Reprojecting geographic data</h2>
<p>Section <a href="spatial-class.html#crs-intro">2.3</a> demonstrated the importance of understanding CRSs for geocomputation. Many spatial operations assume that you are using a <em>projected</em> CRS (on a Euclidean grid with units of meters rather than a geographic ‘lat/lon’ grid with units of degrees). The GEOS engine underlying most spatial operations in <strong>sf</strong>, for example, assumes your data is in a projected CRS. For this reason <strong>sf</strong> contains a function for checking if geometries have a geographic or projected CRS. This is illustrated below using the example of <em>London</em>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">london =<span class="st"> </span><span class="kw">st_sf</span>(<span class="dt">geometry =</span> <span class="kw">st_sfc</span>(<span class="kw">st_point</span>(<span class="kw">c</span>(-<span class="fl">0.1</span>, <span class="fl">51.5</span>))))
<span class="kw">st_is_longlat</span>(london)
<span class="co">#&gt; [1] NA</span></code></pre></div>
<p>The results show that when geographic data is created from scratch, or is loaded from a source that has no CRS metadata, the CRS is unspecified by default. The CRS can be set with <code>st_set_crs()</code>:<a href="#fn22" class="footnoteRef" id="fnref22"><sup>22</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">london =<span class="st"> </span><span class="kw">st_set_crs</span>(london, <span class="dv">4326</span>)
<span class="kw">st_is_longlat</span>(london)
<span class="co">#&gt; [1] TRUE</span></code></pre></div>
<p>Spatial operations on objects without a CRS run on the implicit assumption that they are projected, even when in reality they are not. This can lead to problems, as illustrated by the following code chunk, which creates a buffer of one degree around <code>london</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">london_buff =<span class="st"> </span><span class="kw">st_buffer</span>(london, <span class="dt">dist =</span> <span class="dv">1</span>)
<span class="co">#&gt; Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs): st_buffer does</span>
<span class="co">#&gt; not correctly buffer longitude/latitude data</span>
<span class="co">#&gt; dist is assumed to be in decimal degrees (arc_degrees).</span></code></pre></div>
<p>Note the warning that informs us that the result has limited use because distances in geographic CRSs are in degrees, rather than meters or some other suitable measure of distance. The consequences of a failure to work on projected data are illustrated in Figure <a href="transform.html#fig:crs-buf">5.1</a>: note how the buffer is elongated in the north-south direction. This because lines of longitude converge towards the Earth’s poles.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(london_buff, <span class="dt">graticule =</span> <span class="kw">st_crs</span>(<span class="dv">4326</span>), <span class="dt">axes =</span> <span class="ot">TRUE</span>)
<span class="kw">plot</span>(london, <span class="dt">add =</span> <span class="ot">TRUE</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:crs-buf"></span>
<img src="figures/crs-buf-1.png" alt="Buffer on data with geographic CRS." width="576" />
<p class="caption">
Figure 5.1: Buffer on data with geographic CRS.
</p>
</div>
<p>Do not interpret the warning about the geographic (<code>longitude/latitude</code>) CRS as “the CRS should not be set”: it almost always should be! It is better understood as a suggestion to <em>reproject</em> the data onto a projected CRS. This suggestion does not always need to be heeded: performing spatial and geometric operations makes little or no difference some cases (e.g. spatial subsetting). But for operations involving distances such as buffering, the only way to ensure a good result is to create a projected copy of the data and run the operation on that. This is done in the command below, using the <strong>sf</strong> function <code>st_transform()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">london_proj =<span class="st"> </span><span class="kw">st_transform</span>(london, <span class="dt">crs =</span> <span class="dv">27700</span>)</code></pre></div>
<p>The result is a new object that is identical to <code>london</code>, but reprojected onto a suitable CRS (the British National Grid, which has an EPSG code of 27700 in this case) that has units of meters. We can verify that the CRS has changed using <code>st_crs()</code> as follows (only the most important components of the output are shown, other details have been replaced by <code>...</code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_crs</span>(london_proj)
<span class="co">#&gt; Coordinate Reference System:</span>
<span class="co">#&gt;   EPSG: 27700 </span>
<span class="co">#&gt;   proj4string: &quot;+proj=tmerc +lat_0=49 +lon_0=-2 ... +units=m +no_defs&quot;</span></code></pre></div>
<p>Notable components of this CRS description include the EPSG code (<code>EPSG: 27700</code>), the origin (<code>+lat_0=49 +lon_0=-2</code>) and units (<code>+units=m</code>). The fact that the units of the CRS are meters (rather than degrees) tells us that geometry operations on on <code>london_proj</code> will make sense (and not emit a warning). This can be verified by checking that it is no longer in a geographic CRS, that <code>st_is_longlat(london_proj)</code> returns <code>FALSE</code>. Now we can repeat the buffer operation with a meaningful measure of distance. Moving 1 degree at the equator means moving more than 100 km (111,320 meters), the new buffer distance:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">london_proj_buff =<span class="st"> </span><span class="kw">st_buffer</span>(london_proj, <span class="dv">111320</span>)</code></pre></div>
<p>The result in Figure <a href="transform.html#fig:crs-buf-proj">5.2</a> shows that buffers based on a projected CRS are not distorted: it is the same distance from London to every part of the buffer’s border.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(london_proj_buff, <span class="dt">graticule =</span> <span class="kw">st_crs</span>(<span class="dv">27700</span>), <span class="dt">axes =</span> <span class="ot">TRUE</span>)
<span class="kw">plot</span>(london_proj, <span class="dt">add =</span> <span class="ot">TRUE</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:crs-buf-proj"></span>
<img src="figures/crs-buf-proj-1.png" alt="Buffer on data with projected CRS." width="576" />
<p class="caption">
Figure 5.2: Buffer on data with projected CRS.
</p>
</div>
<div id="reprojecting-vector-geometries" class="section level3">
<h3><span class="header-section-number">5.1.1</span> Reprojecting vector geometries</h3>
<p>While CRSs can be set manually, it is more common in real world applications to <em>transform</em> a known CRS into another. CRS transformation could be vital to obtain proper results in many cases. A typical example is when geometry data is provided in a geographic CRS but you want to do spatial operations, which require it to be in a projected CRS. It includes distance measurements or area calculations. CRS also represent spatial relationship between datasets. Therefore, spatial operations on many datasets can only be correctly performed when all the data have the same CRS. The most common reason to unify the CRS is to combine different datasets or apply methods which need at least two objects. Let’s use real-world examples to illustrate this.</p>
<p>Vector data on the most basic level is represented by individual points, and points create more complex objects, such as lines and polygons. Spatial reprojection of vectors is a mathematical transformation of coordinates of these point. Depending on projections used, reprojection could be either lossy or lossless. For example, loss of spatial information could occur when the new CRS is only adequate for smaller area than input vector. The precision could be also lost when transformation is between coordinate systems that have different datum - in those situations approximations are used. However, in most cases CRS vector transformation is lossless.</p>
<p>The dataset <code>cycle_hire_osm</code> represents all cycle hire locations across London, taken from OpenStreetMap (OSM). It is automatically loaded by the <strong>spData</strong> package, meaning we do not have to load it, and its CRS can be queried as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_crs</span>(cycle_hire_osm)
<span class="co">#&gt; Coordinate Reference System:</span>
<span class="co">#&gt;   EPSG: 4326 </span>
<span class="co">#&gt;   proj4string: &quot;+proj=longlat +datum=WGS84 +no_defs&quot;</span></code></pre></div>
<p>CRS in R can be described as an <code>epsg</code> code or a <code>proj4string</code> definition, as described in section <a href="spatial-class.html#crs-in-r">2.3.3</a>. Let’s create a new version of <code>cycle_hire_osm</code> in a projected CRS, using the <code>epsg</code> number of 27700:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cycle_hire_osm_projected =<span class="st"> </span><span class="kw">st_transform</span>(cycle_hire_osm, <span class="dv">27700</span>)
<span class="kw">st_crs</span>(cycle_hire_osm_projected)
<span class="co">#&gt; Coordinate Reference System:</span>
<span class="co">#&gt;   EPSG: 27700 </span>
<span class="co">#&gt;   proj4string: &quot;+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +towgs84=446.448,-125.157,542.06,0.15,0.247,0.842,-20.489 +units=m +no_defs&quot;</span></code></pre></div>
<p>Note that the result shows that the <code>epsg</code> has been updated and that <code>proj4string</code> element of the CRS now contains, among other things <code>+proj=tmerc</code> (meaning it is a projected CRS using the <a href="https://en.wikipedia.org/wiki/Transverse_Mercator_projection">tranverse Mercator</a> projection) and <code>+units=m</code> (meaning the units of the coordinates are meters). Another function, from the <strong>rgdal</strong> library, provides a note containing the name of the CRS:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">crs_codes =<span class="st"> </span>rgdal::<span class="kw">make_EPSG</span>()[<span class="dv">1</span>:<span class="dv">2</span>]
dplyr::<span class="kw">filter</span>(crs_codes, code ==<span class="st"> </span><span class="dv">27700</span>)
<span class="co">#&gt;    code                                note</span>
<span class="co">#&gt; 1 27700 # OSGB 1936 / British National Grid</span></code></pre></div>
<p>The result shows that the EPSG code 27700 represents the British National Grid, a result that could have been found by searching online for “<a href="https://www.google.com/search?q=CRS+27700">CRS 27700</a>”. The formula that converts a geographic point into a point on the surface of the Earth is provided by the <code>proj4string</code> element of the <code>crs</code> (see <a href="http://proj4.org/">proj4.org</a> for further details):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_crs</span>(<span class="dv">27700</span>)$proj4string
<span class="co">#&gt; [1] &quot;+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +towgs84=446.448,-125.157,542.06,0.15,0.247,0.842,-20.489 +units=m +no_defs&quot;</span></code></pre></div>

<div class="rmdnote">
The EPSG code can be found inside the <code>crs</code> attribute of the object’s geometry. It is hidden from view for most of the time except when the object is printed but can be can identified and set using the <code>st_crs</code> function, for example <code>st_crs(cycle_hire_osm)$epsg</code>.
</div>
<p></p>
<p>Existing CRS are well suited for most purposes. <!-- examples --> In the same time, <code>proj4string</code> definitions are highly modifiable and allow for CRS customization. <!-- as we mentioned in section \@ref(crs-in-r). --> We can present that using selected world projections. The Mollweide projection is recommended when it is important to preserve areas <span class="citation">(Jenny et al. <a href="#ref-jenny_guide_2017">2017</a>)</span> (Figure <a href="transform.html#fig:mollproj">5.3</a>). To use this projection, we need to specify it using the <code>proj4string</code> element, <code>&quot;+proj=moll&quot;</code>, in the <code>st_transform</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world_mollweide =<span class="st"> </span><span class="kw">st_transform</span>(world, <span class="dt">crs =</span> <span class="st">&quot;+proj=moll&quot;</span>)</code></pre></div>
<!-- plot(world_mollweide$geom) -->
<!-- plot(world_mollweide$geom, graticule = TRUE) -->
<div class="figure" style="text-align: center"><span id="fig:mollproj"></span>
<img src="figures/mollproj-1.png" alt="Mollweide projection of the world" width="576" />
<p class="caption">
Figure 5.3: Mollweide projection of the world
</p>
</div>
<p>On the other hand, the goal for many visualization purposes is to have a map with minimized area, direction, and distance distortions. One of the most popular projection to achieve that is Winkel tripel (Figure <a href="transform.html#fig:wintriproj">5.4</a>).<a href="#fn23" class="footnoteRef" id="fnref23"><sup>23</sup></a> <code>st_transform_proj()</code> from the <strong>lwgeom</strong> package allows for coordinates transformations to a wider range of CRSs, inluding the Winkel tripel projection:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world_wintri =<span class="st"> </span>lwgeom::<span class="kw">st_transform_proj</span>(world, <span class="dt">crs =</span> <span class="st">&quot;+proj=wintri&quot;</span>)</code></pre></div>
<!-- plot(world_wintri$geom) -->
<!-- plot(world_wintri$geom, graticule = TRUE) -->
<div class="figure" style="text-align: center"><span id="fig:wintriproj"></span>
<img src="figures/wintriproj-1.png" alt="Winkel tripel projection of the world" width="576" />
<p class="caption">
Figure 5.4: Winkel tripel projection of the world
</p>
</div>

<div class="rmdnote">
Two main functions for transformation of simple features coordinates are <code>sf::st_transform()</code> and <code>sf::sf_project()</code>. The <code>st_transform</code> function uses the GDAL interface to PROJ.4, while <code>sf_project()</code> (which works on point data only) and <code>lwgeom::st_transform_proj()</code> use the PROJ.4 API directly. The first one is appropriate in most situations, and provides a set of the most often used parameters and well defined transformations. The second one allows for a greater customization of a projection, which includes cases when some of the PROJ.4 parameters (e.g. <code>+over</code>) or projection (<code>+proj=wintri</code>) is not available in <code>st_transform()</code>.
</div>
<p></p>
<p>Moreover, PROJ.4 parameters can be modified in most CRS definitions. The below code transforms the coordinates to the Lambert azimuthal equal-area projection centered on longitude and latitude of <code>0</code> (Figure <a href="transform.html#fig:laeaproj1">5.5</a>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world_laea1 =<span class="st"> </span><span class="kw">st_transform</span>(world, <span class="dt">crs =</span> <span class="st">&quot;+proj=laea +x_0=0 +y_0=0 +lon_0=0 +lat_0=0&quot;</span>)</code></pre></div>
<!-- plot(world_laea1$geom) -->
<!-- plot(world_laea1$geom, graticule = TRUE) -->
<div class="figure" style="text-align: center"><span id="fig:laeaproj1"></span>
<img src="figures/laeaproj1-1.png" alt="Lambert azimuthal equal-area projection of the world centered on longitude and latitude of 0" width="576" />
<p class="caption">
Figure 5.5: Lambert azimuthal equal-area projection of the world centered on longitude and latitude of 0
</p>
</div>
<p>We can change the PROJ.4 parameters, for example the center of the projection using the <code>+lon_0</code> and <code>+lat_0</code> parameters. The code below gives the map centered on New York City (Figure <a href="transform.html#fig:laeaproj2">5.6</a>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world_laea2 =<span class="st"> </span><span class="kw">st_transform</span>(world, <span class="dt">crs =</span> <span class="st">&quot;+proj=laea +x_0=0 +y_0=0 +lon_0=-74 +lat_0=40&quot;</span>)</code></pre></div>
<!-- plot(world_laea2$geom) -->
<!-- plot(world_laea2$geom, graticule = TRUE) -->
<div class="figure" style="text-align: center"><span id="fig:laeaproj2"></span>
<img src="figures/laeaproj2-1.png" alt="Lambert azimuthal equal-area projection of the world centered on New York City" width="576" />
<p class="caption">
Figure 5.6: Lambert azimuthal equal-area projection of the world centered on New York City
</p>
</div>
<p>More information about CRS modification can be found in the <a href="http://proj4.org/usage/index.html">Using PROJ.4</a> documentation.</p>
<!-- https://github.com/r-spatial/lwgeom/issues/6 -->
<!-- ```{r} -->
<!-- # devtools::install_github("r-spatial/lwgeom") -->
<!-- library(lwgeom) -->
<!-- world_3 = lwgeom::st_transform_proj(world, crs = "+proj=wintri") -->
<!-- plot(world_3$geom) -->
<!-- ``` -->
<!-- http://bl.ocks.org/vlandham/raw/9216751/ -->
</div>
<div id="reprojecting-raster-geometries" class="section level3">
<h3><span class="header-section-number">5.1.2</span> Reprojecting raster geometries</h3>
<p>The projection concepts described in the previous section apply equally to rasters. However, there are important differences in reprojection of vectors and rasters: transforming a vector object involves changing the coordinates of every vertex but this do not apply to raster data. Rasters are are composed of rectangular cells of the same size (expressed by map units, such as degrees or meters), so it is impossible to transform coordinates of pixels separately.</p>
<p>Raster reprojection involves creating a new raster object, often with a different number of columns and rows than the original. The attributes must subsequently be re-estimated, allowing the new pixels to be ‘filled’ with appropriate values. This two-stage process is done with <code>projectRaster()</code> from the <strong>raster</strong> package. Like the <code>st_transform()</code> function demonstrated in the previous section, <code>projectRaster()</code> takes a geographic object (a raster dataset in this case) and a <code>crs</code> argument. However, <code>projectRaster()</code> only accepts the lengthy <code>proj4string</code> definitions of a CRS rather than concise EPSG codes.</p>

<div class="rmdnote">
It is possible to use a EPSG code in a <code>proj4string</code> definition with <code>&quot;+init=epsg:MY_NUMBER&quot;</code>. For example, one can use the <code>&quot;+init=epsg:4326&quot;</code> definition to set CRS to WGS84 (EPSG code of 4326). The PROJ.4 library automatically adds the rest of parameters and converts it into <code>&quot;+init=epsg:4326 +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0&quot;</code>,
</div>
<p></p>
<p>Let’s take a look at two examples of raster transformation - using categorical and continuous data. Land cover data are usually represented by categorical maps. The <code>nlcd2011.tif</code> file provides information for a small area in Utah, USA obtained from <a href="https://www.mrlc.gov/nlcd2011.php">National Land Cover Database 2011</a> in the NAD83 / UTM zone 12N CRS.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cat_raster =<span class="st"> </span><span class="kw">raster</span>(<span class="kw">system.file</span>(<span class="st">&quot;raster/nlcd2011.tif&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;spDataLarge&quot;</span>))
cat_raster
<span class="co">#&gt; class       : RasterLayer </span>
<span class="co">#&gt; dimensions  : 1359, 1073, 1458207  (nrow, ncol, ncell)</span>
<span class="co">#&gt; resolution  : 31.5, 31.5  (x, y)</span>
<span class="co">#&gt; extent      : 301903, 335735, 4111244, 4154086  (xmin, xmax, ymin, ymax)</span>
<span class="co">#&gt; coord. ref. : +proj=utm +zone=12 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs </span>
<span class="co">#&gt; data source : /home/travis/R/Library/spDataLarge/raster/nlcd2011.tif </span>
<span class="co">#&gt; names       : nlcd2011 </span>
<span class="co">#&gt; values      : 11, 95  (min, max)</span></code></pre></div>
<p>In this region, 14 land cover classes were distinguished<a href="#fn24" class="footnoteRef" id="fnref24"><sup>24</sup></a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">unique</span>(cat_raster)
<span class="co">#&gt;  [1] 11 21 22 23 31 41 42 43 52 71 81 82 90 95</span></code></pre></div>
<p>When reprojecting categorical raster, we need to ensure that our new estimated values would still have values of our original classes. This could be done using the nearest neighbor method (<code>ngb</code>). In this method, value of the output cell is calculated based on the nearest cell center of the input raster.</p>
<p>For example, we want to change the CRS to WGS 84.<br />
It can be desired when we want to visualize a raster data on top of a web basemaps, such as the Google or OpenStreetMap map tiles. The first step is to obtain the proj4 definition of this CRS, which can be done using the <a href="http://spatialreference.org/ref/epsg/wgs-84/">http://spatialreference.org</a> webpage. The second and last step is to define the reprojection method in the <code>projectRaster()</code> function, which in case of categorical data is the nearest neighbor method (<code>ngb</code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">wgs84 =<span class="st"> &quot;+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs&quot;</span>
cat_raster_wgs84 =<span class="st"> </span><span class="kw">projectRaster</span>(cat_raster, <span class="dt">crs =</span> wgs84, <span class="dt">method =</span> <span class="st">&quot;ngb&quot;</span>)
cat_raster_wgs84
<span class="co">#&gt; class       : RasterLayer </span>
<span class="co">#&gt; dimensions  : 1394, 1111, 1548734  (nrow, ncol, ncell)</span>
<span class="co">#&gt; resolution  : 0.000356, 0.000284  (x, y)</span>
<span class="co">#&gt; extent      : -113, -113, 37.1, 37.5  (xmin, xmax, ymin, ymax)</span>
<span class="co">#&gt; coord. ref. : +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0 </span>
<span class="co">#&gt; data source : in memory</span>
<span class="co">#&gt; names       : nlcd2011 </span>
<span class="co">#&gt; values      : 11, 95  (min, max)</span></code></pre></div>
<p>Many properties of the new object differs from the previous one, which include the number of columns and rows (and therefore number of cells), resolution (transformed from meters into degrees), and extent. In the same time, it keeps the same land cover classes - <code>unique(cat_raster_wgs84)</code>. <!-- freq(cat_raster_wgs84) --> <!-- freq(cat_raster) --></p>
<p>This process of reprojection is almost identical for continuous data. The <code>srtm.tif</code> file contains digital elevation model for the same area in Utah from <a href="https://www2.jpl.nasa.gov/srtm/">the Shuttle Radar Topography Mission (SRTM)</a>. Each value in this raster represents elevation measured in meters.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">con_raster =<span class="st"> </span><span class="kw">raster</span>(<span class="kw">system.file</span>(<span class="st">&quot;raster/srtm.tif&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;spDataLarge&quot;</span>))
con_raster
<span class="co">#&gt; class       : RasterLayer </span>
<span class="co">#&gt; dimensions  : 457, 465, 212505  (nrow, ncol, ncell)</span>
<span class="co">#&gt; resolution  : 0.000833, 0.000833  (x, y)</span>
<span class="co">#&gt; extent      : -113, -113, 37.1, 37.5  (xmin, xmax, ymin, ymax)</span>
<span class="co">#&gt; coord. ref. : +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 </span>
<span class="co">#&gt; data source : /home/travis/R/Library/spDataLarge/raster/srtm.tif </span>
<span class="co">#&gt; names       : srtm </span>
<span class="co">#&gt; values      : 1024, 2892  (min, max)</span></code></pre></div>
<p>The nearest neighbor method should not be used for continuous raster data, as we want to preserve gradual changes in values. Alternatively, continuous data could be reprojected in the <strong>raster</strong> package using the bi-linear method. In this technique, value of the output cell is calculated based on four nearest cells in the original raster. The new value is a weighted average of values from these four cells, adjusted for their distance from the center of the output cell. This dataset has geographic CRS and we want to transform it into projected CRS.</p>

<div class="rmdnote">
All the grid cells in equal-area projections have the same size. Therefore, these projections are recommended when performing many raster operations, such as distance calculations.
</div>
<p></p>
<p>In the fist step we need to obtain the proj4 definition of the existing projected CRS appropriate for this area or create a new one using the <a href="http://projectionwizard.org/">Projection Wizard</a> online tool <span class="citation">(Šavrič, Jenny, and Jenny <a href="#ref-savric_projection_2016">2016</a>)</span>. For this example, we used the Oblique Lambert azimuthal equal-area projection. The second step is to define the <code>bilinear</code> reprojection method:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">equalarea =<span class="st"> &quot;+proj=laea +lat_0=37.32 +lon_0=-113.04&quot;</span>
con_raster_ea =<span class="st"> </span><span class="kw">projectRaster</span>(con_raster, <span class="dt">crs =</span> equalarea, <span class="dt">method =</span> <span class="st">&quot;bilinear&quot;</span>)
con_raster_ea
<span class="co">#&gt; class       : RasterLayer </span>
<span class="co">#&gt; dimensions  : 467, 478, 223226  (nrow, ncol, ncell)</span>
<span class="co">#&gt; resolution  : 73.9, 92.5  (x, y)</span>
<span class="co">#&gt; extent      : -18178, 17146, -21306, 21892  (xmin, xmax, ymin, ymax)</span>
<span class="co">#&gt; coord. ref. : +proj=laea +lat_0=37.32 +lon_0=-113.04 +ellps=WGS84 </span>
<span class="co">#&gt; data source : in memory</span>
<span class="co">#&gt; names       : srtm </span>
<span class="co">#&gt; values      : 1027, 2891  (min, max)</span></code></pre></div>
<p>Reprojection of continuous rasters also changes spatial properties, such as the number of cells, resolution, and extent. Moreover, it slightly modifies values in the new raster, which can be seen by comparing the outputs of the <code>summary()</code> function between <code>con_raster</code> and <code>con_raster_ea</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(con_raster)
<span class="kw">summary</span>(con_raster_ea)</code></pre></div>
<!-- why new na? -->
<!-- res option in projectRaster? -->
<!-- note1: in most of the cases reproject vector, not raster-->
<!-- note2: equal area projections are the best for raster calculations -->
<!-- q: should we mentioned gdal_transform? -->
</div>
</div>
<div id="geo-vec" class="section level2">
<h2><span class="header-section-number">5.2</span> Geometric operations on vector data</h2>
<p>This section is about operations that in some way change the geometry of vector (<code>sf</code>) objects. It is more advanced than the spatial data operations presented in the previous Chapter (in section <a href="spatial-operations.html#spatial-operations-on-vector-data">4.2</a>) because here we drill down into the geometry: the functions discussed in this section work on objects of class <code>sfc</code> (simple feature geometry collections) in addition to objects of class <code>sf</code>.</p>
<div id="geometry-unions" class="section level3">
<h3><span class="header-section-number">5.2.1</span> Geometry unions</h3>
<p>Spatial aggregation can also be done in the <strong>tidyverse</strong>, using <strong>dplyr</strong> functions as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">group_by</span>(us_states, REGION) %&gt;%
<span class="st">  </span><span class="kw">summarize</span>(<span class="kw">sum</span>(<span class="dt">pop =</span> total_pop_15, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))</code></pre></div>
<p>For attribute data aggregation the grouping variable is another variable, typically one with few unique values relative to the number of rows (see section <a href="attr.html#vector-attribute-aggregation">3.2.2</a>). What we did not cover in that section was that attribute data aggregation dissolves the geometries of touching polygons. The <code>REGION</code> variable in the <code>us_states</code> dataset is a good example: there are 49 states (excluding Hawaii and Alaska) which can be aggregated into four regions. This is demonstrated in the code chunk below, the results of which are illustrated in Figure <a href="transform.html#fig:us-regions">5.7</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">regions =<span class="st"> </span><span class="kw">aggregate</span>(<span class="dt">x =</span> us_states[, <span class="st">&quot;total_pop_15&quot;</span>], <span class="dt">by =</span> <span class="kw">list</span>(us_states$REGION),
                    <span class="dt">FUN =</span> sum, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</code></pre></div>
<!--
show also tidyverse way, so what you are doing is basically a spatial join and a subsequent aggregation without a grouping variable. Didactically, it might be better to present a grouping variable.
-->
<div class="figure" style="text-align: center"><span id="fig:us-regions"></span>
<img src="figures/us-regions-1.png" alt="Spatial aggregation on contiguous polygons, illustrated by aggregating the population of US states into regions, with population represented by color. Note the operation automatically dissolves boundaries between states." width="100%" />
<p class="caption">
Figure 5.7: Spatial aggregation on contiguous polygons, illustrated by aggregating the population of US states into regions, with population represented by color. Note the operation automatically dissolves boundaries between states.
</p>
</div>
<p>The equivalent result can be achieved using <strong>tidyverse</strong> functions as follows (result not shown):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">regions2 =<span class="st"> </span>us_states %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(REGION) %&gt;%
<span class="st">  </span><span class="kw">summarize</span>(<span class="kw">sum</span>(<span class="dt">pop =</span> total_pop_15, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))</code></pre></div>
</div>
<div id="clipping" class="section level3">
<h3><span class="header-section-number">5.2.2</span> Clipping</h3>
<p>Spatial clipping is a form of spatial subsetting that involves changes to the <code>geometry</code> columns of at least some of the affected features.</p>
<p>Clipping can only apply to features more complex than points: lines, polygons and their ‘multi’ equivalents. To illustrate the concept we will start with a simple example: two overlapping circles with a center point one unit away from each other and radius of one:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b =<span class="st"> </span><span class="kw">st_sfc</span>(<span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>)), <span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>))) <span class="co"># create 2 points</span>
b =<span class="st"> </span><span class="kw">st_buffer</span>(b, <span class="dt">dist =</span> <span class="dv">1</span>) <span class="co"># convert points to circles</span>
l =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>)
<span class="kw">plot</span>(b)
<span class="kw">text</span>(<span class="dt">x =</span> <span class="kw">c</span>(-<span class="fl">0.5</span>, <span class="fl">1.5</span>), <span class="dt">y =</span> <span class="dv">1</span>, <span class="dt">labels =</span> l) <span class="co"># add text</span></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:points"></span>
<img src="figures/points-1.png" alt="Overlapping circles." width="576" />
<p class="caption">
Figure 5.8: Overlapping circles.
</p>
</div>
<p>Imagine you want to select not one circle or the other, but the space covered by both <code>x</code> <em>and</em> <code>y</code>. This can be done using the function <code>st_intersection()</code>, illustrated using objects named <code>x</code> and <code>y</code> which represent the left and right-hand circles:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x =<span class="st"> </span>b[<span class="dv">1</span>]
y =<span class="st"> </span>b[<span class="dv">2</span>]
x_and_y =<span class="st"> </span><span class="kw">st_intersection</span>(x, y)
<span class="kw">plot</span>(b)
<span class="kw">plot</span>(x_and_y, <span class="dt">col =</span> <span class="st">&quot;lightgrey&quot;</span>, <span class="dt">add =</span> <span class="ot">TRUE</span>) <span class="co"># color intersecting area</span></code></pre></div>
<p><img src="figures/unnamed-chunk-32-1.png" width="576" style="display: block; margin: auto;" /></p>
<p>The subsequent code chunk demonstrate how this works for all combinations of the ‘Venn’ diagram representing <code>x</code> and <code>y</code>, inspired by <a href="http://r4ds.had.co.nz/transform.html#logical-operators">Figure 5.1</a> of the book R for Data Science <span class="citation">(Grolemund and Wickham <a href="#ref-grolemund_r_2016">2016</a>)</span>. <!-- Todo: reference r4ds --></p>
<div class="figure" style="text-align: center"><span id="fig:venn-clip"></span>
<img src="figures/venn-clip-1.png" alt="Spatial equivalents of logical operators." width="576" />
<p class="caption">
Figure 5.9: Spatial equivalents of logical operators.
</p>
</div>
<p>To illustrate the relationship between subsetting and clipping spatial data, we will subset points that cover the bounding box of the circles <code>x</code> and <code>y</code> in Figure <a href="transform.html#fig:venn-clip">5.9</a>. Some points will be inside just one circle, some will be inside both and some will be inside neither.</p>
<p>There are two different ways to subset points that fit into combinations of the circles: via clipping and logical operators. But first we must generate some points. We will use the <em>simple random</em> sampling strategy to sample from a box representing the extent of <code>x</code> and <code>y</code>. To generate this points will use a function not yet covered in this book, <code>st_sample()</code>. Next we will generate the situation plotted in Figure <a href="transform.html#fig:venn-subset">5.10</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bb =<span class="st"> </span><span class="kw">st_bbox</span>(<span class="kw">st_union</span>(x, y))
pmat =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(bb[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">2</span>)]), <span class="dt">ncol =</span> <span class="dv">2</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)
box =<span class="st"> </span><span class="kw">st_polygon</span>(<span class="kw">list</span>(pmat))
<span class="kw">set.seed</span>(<span class="dv">2017</span>)
p =<span class="st"> </span><span class="kw">st_sample</span>(<span class="dt">x =</span> box, <span class="dt">size =</span> <span class="dv">10</span>)
<span class="kw">plot</span>(box)
<span class="kw">plot</span>(x, <span class="dt">add =</span> <span class="ot">TRUE</span>)
<span class="kw">plot</span>(y, <span class="dt">add =</span> <span class="ot">TRUE</span>)
<span class="kw">plot</span>(p, <span class="dt">add =</span> <span class="ot">TRUE</span>)
<span class="kw">text</span>(<span class="dt">x =</span> <span class="kw">c</span>(-<span class="fl">0.5</span>, <span class="fl">1.5</span>), <span class="dt">y =</span> <span class="dv">1</span>, <span class="dt">labels =</span> l)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:venn-subset"></span>
<img src="figures/venn-subset-1.png" alt="Randomly distributed points within the bounding box enclosing circles x and y." width="576" />
<p class="caption">
Figure 5.10: Randomly distributed points within the bounding box enclosing circles x and y.
</p>
</div>
</div>
<div id="centroids" class="section level3">
<h3><span class="header-section-number">5.2.3</span> Centroids</h3>
<!-- st_point_on_surface -->
<!-- st_centroid -->
<!-- st_polygonize -->
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">nz_centroid =<span class="st"> </span><span class="kw">st_centroid</span>(nz)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">nz_pos =<span class="st"> </span><span class="kw">st_point_on_surface</span>(nz)</code></pre></div>
<p><img src="figures/unnamed-chunk-36-1.png" width="576" style="display: block; margin: auto;" /></p>
</div>
<div id="buffers" class="section level3">
<h3><span class="header-section-number">5.2.4</span> Buffers</h3>
</div>
<div id="affine-transformations" class="section level3">
<h3><span class="header-section-number">5.2.5</span> Affine transformations</h3>
</div>
<div id="type-transformation" class="section level3">
<h3><span class="header-section-number">5.2.6</span> Type transformation</h3>
<p>Geometry casting is powerful operation which enable transformation of the geometry type. It is implemented in the <code>st_cast</code> function from the <code>sf</code> package. Importantly, <code>st_cast</code> behaves differently on single simple feature geometry (<code>sfg</code>) objects, and simple feature geometry column (<code>sfc</code>) and simple features objects.</p>
<p>Let’s create a multipoint to illustrate how geometry casting works on simple feature geometry (<code>sfg</code>) objects:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">multipoint =<span class="st"> </span><span class="kw">st_multipoint</span>(<span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">1</span>), <span class="dt">ncol =</span> <span class="dv">2</span>))</code></pre></div>
<p>In this case, <code>st_cast</code> can be useful to transform the new object into linestring or polygon (Figure <a href="transform.html#fig:single-cast">5.11</a>):</p>
<!-- a/ points -> lines -> polygons  -->
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">linestring =<span class="st"> </span><span class="kw">st_cast</span>(multipoint, <span class="st">&quot;LINESTRING&quot;</span>)
polyg =<span class="st"> </span><span class="kw">st_cast</span>(multipoint, <span class="st">&quot;POLYGON&quot;</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:single-cast"></span>
<img src="figures/single-cast-1.png" alt="Examples of linestring and polygon created based on multipoint using the `st_cast` function" width="576" />
<p class="caption">
Figure 5.11: Examples of linestring and polygon created based on multipoint using the <code>st_cast</code> function
</p>
</div>
<p>This process can be also reversed using <code>st_cast</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">multipoint_2 =<span class="st"> </span><span class="kw">st_cast</span>(linestring, <span class="st">&quot;MULTIPOINT&quot;</span>)
multipoint_3 =<span class="st"> </span><span class="kw">st_cast</span>(polyg, <span class="st">&quot;MULTIPOINT&quot;</span>)
<span class="kw">all.equal</span>(multipoint, multipoint_2, multipoint_3)
<span class="co">#&gt; [1] TRUE</span></code></pre></div>

<div class="rmdnote">
For single simple feature geometries (<code>sfg</code>), <code>st_cast</code> provides also geometry casting from non-multi to multi types (e.g. <code>POINT</code> to <code>MULTIPOINT</code>) and from multi types to non-multi types. However, only the first element of the old object would remain in the second group of cases. <!-- note: beware of information lost (you will get a warning) -->
</div>
<p></p>
<p>Geometry casting of simple feature geometry column (<code>sfc</code>) and simple features objects works the same as for single geometries in most of the cases. One imporant difference is conversion between multi to non-multi types. As a result of this process, multi-objects are split into many non-multi objects.</p>
<p>We would use a new object, <code>multilinestring_sf</code>, as an example (on the left in Figure <a href="transform.html#fig:line-cast">5.12</a>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">multilinestring_list =<span class="st"> </span><span class="kw">list</span>(<span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">3</span>), <span class="dt">ncol =</span> <span class="dv">2</span>), 
                            <span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">4</span>, <span class="dv">1</span>), <span class="dt">ncol =</span> <span class="dv">2</span>),
                            <span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">2</span>), <span class="dt">ncol =</span> <span class="dv">2</span>))
multilinestring =<span class="st"> </span><span class="kw">st_multilinestring</span>((multilinestring_list))
multilinestring_sf =<span class="st"> </span><span class="kw">st_sf</span>(<span class="dt">geom =</span> <span class="kw">st_sfc</span>(multilinestring))
multilinestring_sf
<span class="co">#&gt; Simple feature collection with 1 feature and 0 fields</span>
<span class="co">#&gt; geometry type:  MULTILINESTRING</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 1 ymin: 1 xmax: 4 ymax: 5</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt;                             geom</span>
<span class="co">#&gt; 1 MULTILINESTRING ((1 5, 4 3)...</span></code></pre></div>
<p>You can imagine it as a road or river network. The new object has only one row that define all the lines. This restrict number of operation that could be done, for example it prevent adding names to each line segment or calculating lengths of single lines. The <code>st_cast</code> function can be used in this situation, as it separates one mutlilinestring into three linestrings:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">linestring_sf2 =<span class="st"> </span><span class="kw">st_cast</span>(multilinestring_sf, <span class="st">&quot;LINESTRING&quot;</span>)
linestring_sf2
<span class="co">#&gt; Simple feature collection with 3 features and 0 fields</span>
<span class="co">#&gt; geometry type:  LINESTRING</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 1 ymin: 1 xmax: 4 ymax: 5</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt;                geometry</span>
<span class="co">#&gt; 1 LINESTRING (1 5, 4 3)</span>
<span class="co">#&gt; 2 LINESTRING (4 4, 4 1)</span>
<span class="co">#&gt; 3 LINESTRING (2 2, 4 2)</span></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:line-cast"></span>
<img src="figures/line-cast-1.png" alt="Examples of type cast between MULTILINESTRING (left) and LINESTRING (right)" width="576" />
<p class="caption">
Figure 5.12: Examples of type cast between MULTILINESTRING (left) and LINESTRING (right)
</p>
</div>
<p>The newely created object allows for attributes creation (see more in section <a href="attr.html#vec-attr-creation">3.2.4</a>) and length measurement:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">linestring_sf2$name =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Riddle Rd&quot;</span>, <span class="st">&quot;Marshall Ave&quot;</span>, <span class="st">&quot;Foulke St&quot;</span>)
linestring_sf2$length =<span class="st"> </span><span class="kw">st_length</span>(linestring_sf2)
linestring_sf2
<span class="co">#&gt; Simple feature collection with 3 features and 2 fields</span>
<span class="co">#&gt; geometry type:  LINESTRING</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 1 ymin: 1 xmax: 4 ymax: 5</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt;                geometry         name length</span>
<span class="co">#&gt; 1 LINESTRING (1 5, 4 3)    Riddle Rd   3.61</span>
<span class="co">#&gt; 2 LINESTRING (4 4, 4 1) Marshall Ave   3.00</span>
<span class="co">#&gt; 3 LINESTRING (2 2, 4 2)    Foulke St   2.00</span></code></pre></div>
<!-- ### Class conversion -->
<!-- placeholder for: -->
<!-- sf -> sp -->
<!-- sp -> sf -->
<!-- stars; https://github.com/r-spatial/stars/blob/master/vignettes/blog1.Rmd -->
</div>
<div id="simplification" class="section level3">
<h3><span class="header-section-number">5.2.7</span> Simplification</h3>
<!-- - simplifications -->
<!-- st_simplify -->
<!-- line example -->
<!-- rmapshaper -->
<!-- polygon example -->
</div>
<div id="rasterization" class="section level3">
<h3><span class="header-section-number">5.2.8</span> Rasterization</h3>
<!-- - vector to raster -->
</div>
</div>
<div id="geo-ras" class="section level2">
<h2><span class="header-section-number">5.3</span> Geometric operations on raster data</h2>
<div id="raster-alignment" class="section level3">
<h3><span class="header-section-number">5.3.1</span> Raster alignment</h3>
<p>When merging or performing map algebra on rasters, their resolution, projection, origin and/or extent has to match. Otherwise, how should we add the values of one raster with a resolution of 0.2 decimal degrees to a second with a resolution of 1 decimal degree? The same problem arises when we would like to merge satellite imagery from different sensors with different projections and resolutions. We can deal with such mismatches by aligning the rasters.</p>
<p>This section uses the <code>elev</code> object from <a href="attr.html#manipulating-raster-objects">3.3</a>. The <code>projectRaster()</code> function reprojects one raster to a desired projection, say from UTM to WGS84. Equally, map algebra operations require the same extent. Following code adds one row and two columns to each side of the raster while setting all new values to an elevation of 1000 meters (<a href="transform.html#fig:extend-example">5.13</a>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">elev_2 =<span class="st"> </span><span class="kw">extend</span>(elev, <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="dt">value =</span> <span class="dv">1000</span>)
<span class="kw">plot</span>(elev_2)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:extend-example"></span>
<img src="figures/extend-example-1.png" alt="Original raster extended by 1 one row on each side (top, bottom) and two columns on each side (right, left)." width="576" />
<p class="caption">
Figure 5.13: Original raster extended by 1 one row on each side (top, bottom) and two columns on each side (right, left).
</p>
</div>
<p>Performing an algebraic operation on two objects with differing extents in R, the <strong>raster</strong> package returns the result for the intersection, and says so in a warning.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">elev_3 =<span class="st"> </span>elev +<span class="st"> </span>elev_2
<span class="co">#&gt; Warning in elev + elev_2: Raster objects have different extents. Result for</span>
<span class="co">#&gt; their intersection is returned</span></code></pre></div>
<p>However, we can also align the extent of two rasters with the <code>extend()</code> command. Here, we extend the <code>elev</code> object to the extend of <code>elev_2</code>. The newly added rows and column receive the default value of the <code>value</code> parameter, i.e., <code>NA</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">elev_4 =<span class="st"> </span><span class="kw">extend</span>(elev, elev_2)</code></pre></div>
<p>The <code>aggregate()</code> and <code>disaggregate()</code> functions help to change the cell size resolution of a raster. For instance, let us aggregate <code>elev</code> from a resolution of 0.5 to a resolution of 1, that means we aggregate by a factor of 2 (Fig. <a href="transform.html#fig:aggregate-example">5.14</a>). Additionally, the output cell value should correspond to the mean of the input cells (but one could use other functions as well such as <code>median()</code>, <code>sum()</code>, etc.):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">elev_agg =<span class="st"> </span><span class="kw">aggregate</span>(elev, <span class="dt">fact =</span> <span class="dv">2</span>, <span class="dt">fun =</span> mean)
<span class="kw">par</span>(<span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>))
<span class="kw">plot</span>(elev)
<span class="kw">plot</span>(elev_agg)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:aggregate-example"></span>
<img src="figures/aggregate-example-1.png" alt="Original raster (left). Aggregated raster (right)." width="576" />
<p class="caption">
Figure 5.14: Original raster (left). Aggregated raster (right).
</p>
</div>
<p>Note that the origin of <code>elev_agg</code> has changed, too.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">origin</span>(elev)
<span class="co">#&gt; [1] 0 0</span>
<span class="kw">origin</span>(elev_agg)
<span class="co">#&gt; [1] 0.5 0.5</span></code></pre></div>
<p>The origin is the point closest to (0, 0) if you moved towards it in steps of x and y resolution. If two rasters have different origins, their cells do not overlap completely which would make map algebra impossible. To change the origin , use <code>origin()</code>.<a href="#fn25" class="footnoteRef" id="fnref25"><sup>25</sup></a> Looking at figure <a href="transform.html#fig:origin-example">5.15</a> reveals the effect of changing the origin.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># plot the aggregated raster</span>
<span class="kw">plot</span>(elev_agg)
<span class="co"># change the origin</span>
<span class="kw">origin</span>(elev_agg) =<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>)
<span class="co"># plot it again</span>
<span class="kw">plot</span>(elev_agg, <span class="dt">add =</span> <span class="ot">TRUE</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:origin-example"></span>
<img src="figures/origin-example-1.png" alt="Plotting rasters with the same values but different origins." width="576" />
<p class="caption">
Figure 5.15: Plotting rasters with the same values but different origins.
</p>
</div>
<p>The <code>resample()</code> command lets you align several raster properties in one go, namely origin, extent and resolution. Let us resample an extended <code>elev_agg</code> to the properties of <code>elev</code> again.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># add 2 rows and columns, i.e. change the extent</span>
elev_agg =<span class="st"> </span><span class="kw">extend</span>(elev_agg, <span class="dv">2</span>)
elev_disagg =<span class="st"> </span><span class="kw">resample</span>(elev_agg, elev)</code></pre></div>
<p>Though our disaggregated <code>elev_disagg</code> retrieved back its original resolution, cell size and extent, its values differ. However, this is to be expected, disaggregating <strong>cannot</strong> predict values at a finer resolution, it simply uses an interpolation algorithm. It is important to keep in mind that disaggregating results in a finer resolution, the corresponding values, however, are only as accurate as their lower resolution source.</p>
<p>Finally, if you want to align many (possibly hundreds or thousands of) images stored on disk, you might want to checkout the <code>gdalUtils::align_rasters()</code> function. Nevertheless, you may also use <strong>raster</strong> with very large datasets. This is because <strong>raster</strong>:</p>
<ol style="list-style-type: decimal">
<li>lets you work with raster datasets that are too large to fit into the main memory (RAM) by only processing chunks of it.</li>
<li>tries to facilitate parallel processing. For more information have a look at the help pages of <code>beginCluster()</code> and <code>clusteR()</code>. Additionally, check out the <em>Multi-core functions</em> section in <code>vignette(&quot;functions&quot;, package = &quot;raster&quot;)</code>.</li>
</ol>
</div>
<div id="ras-agg" class="section level3">
<h3><span class="header-section-number">5.3.2</span> Aggregation</h3>
</div>
<div id="vectorization" class="section level3">
<h3><span class="header-section-number">5.3.3</span> Vectorization</h3>
</div>
</div>
<div id="exercises-3" class="section level2">
<h2><span class="header-section-number">5.4</span> Exercises</h2>
<!-- CRS CONVERSION -->
<!-- 1. vector reprojection exercise (e.g. modification of proj4) -->
<ol style="list-style-type: decimal">
<li>Transform the <code>world</code> dataset to the transverse Mercator projection (<code>&quot;+proj=tmerc&quot;</code>) and plot the result. What has changed and why? Try to transform it back into WGS 84 and plot the new object. Why the new object differs from the original one? <!-- https://github.com/r-spatial/sf/issues/509 --> <!-- ```{r} --> <!-- world_tmerc = st_transform(world, "+proj=tmerc") --> <!-- plot(world_tmerc$geom) --> <!--  world_4326 = st_transform(world_tmerc, 4326) --> <!-- plot(world_4326$geom) --> <!-- ``` --></li>
<li>Try to transform the categorical raster (<code>cat_raster</code>) into WGS 84 using the bi-linear interpolation method. What has changed? How it influences the results? <!-- ```{r} --> <!-- wgs84 = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs" --> <!-- cat_raster_wgs84 = projectRaster(cat_raster, crs = wgs84, method = "bilinear") --> <!-- cat_raster_wgs84 --> <!-- ``` --></li>
<li>Try to transform the continuous raster (<code>cat_raster</code>) into WGS 84 using the nearest neighbor interpolation method. What has changed? How it influences the results? <!-- ```{r} --> <!-- con_raster = raster(system.file("raster/srtm.tif", package="spDataLarge")) --> <!-- con_raster_wgs84 = projectRaster(con_raster, crs = wgs84, method = "ngb") --> <!-- con_raster_wgs84 --> <!-- ``` --> <!-- GEOMETRY TRANSFORMATION --></li>
</ol>

</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-jenny_guide_2017">
<p>Jenny, Bernhard, Bojan Šavrič, Nicholas D Arnold, Brooke E Marston, and Charles A Preppernau. 2017. “A Guide to Selecting Map Projections for World and Hemisphere Maps.” In <em>Choosing a Map Projection</em>, 213–28. Springer.</p>
</div>
<div id="ref-savric_projection_2016">
<p>Šavrič, Bojan, Bernhard Jenny, and Helen Jenny. 2016. “Projection Wizard – An Online Map Projection Selection Tool.” <em>The Cartographic Journal</em> 53 (2): 177–85. doi:<a href="https://doi.org/10.1080/00087041.2015.1131938">10.1080/00087041.2015.1131938</a>.</p>
</div>
<div id="ref-grolemund_r_2016">
<p>Grolemund, Garrett, and Hadley Wickham. 2016. <em>R for Data Science</em>. 1 edition. O’Reilly Media.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="21">
<li id="fn21"><p><strong>lwgeom</strong> is also needed for a couple of more advanced transformations.<a href="transform.html#fnref21">↩</a></p></li>
<li id="fn22"><p>The CRS can also be added when creating <code>sf</code> objects with the <code>crs</code> argument (e.g. <code>st_sf(geometry = st_sfc(st_point(c(-0.1, 51.5))), crs = 4326)</code>). The same argument can also be used to set the CRS when creating raster datasets (e.g. <code>raster(crs = &quot;+proj=longlat&quot;)</code>).<a href="transform.html#fnref22">↩</a></p></li>
<li id="fn23"><p>This projection is used, among others, by the National Geographic Society.<a href="transform.html#fnref23">↩</a></p></li>
<li id="fn24"><p>Full list of NLCD2011 land cover classes can be found at <a href="https://www.mrlc.gov/nlcd11_leg.php" class="uri">https://www.mrlc.gov/nlcd11_leg.php</a><a href="transform.html#fnref24">↩</a></p></li>
<li id="fn25"><p>If the origins of two raster datasets are just marginally apart, it sometimes is sufficient to simply increase the <code>tolerance</code> argument of <code>raster::rasterOptions()</code>.<a href="transform.html#fnref25">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="spatial-operations.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="read-write.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/Robinlovelace/geocompr/edit/master/05-transform.Rmd",
"text": "Edit"
},
"download": null,
"toc": {
"collapse": "section"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
