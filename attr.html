<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Geocomputation with R</title>
  <meta name="description" content="Forthcoming book on geographical data with R.">
  <meta name="generator" content="bookdown 0.5 and GitBook 2.6.7">

  <meta property="og:title" content="Geocomputation with R" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="http://robinlovelace.net/geocompr" />
  
  <meta property="og:description" content="Forthcoming book on geographical data with R." />
  <meta name="github-repo" content="Robinlovelace/geocompr" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Geocomputation with R" />
  
  <meta name="twitter:description" content="Forthcoming book on geographical data with R." />
  

<meta name="author" content="Robin Lovelace, Jakub Nowosad, Jannes Muenchow">


<meta name="date" content="2017-09-19">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="spatial-class.html">
<link rel="next" href="spatial-data-operations.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<script src="libs/htmlwidgets-0.9/htmlwidgets.js"></script>
<link href="libs/leaflet-0.7.7/leaflet.css" rel="stylesheet" />
<script src="libs/leaflet-0.7.7/leaflet.js"></script>
<link href="libs/leafletfix-1.0.0/leafletfix.css" rel="stylesheet" />
<link href="libs/leaflet-label-0.2.2/leaflet.label.css" rel="stylesheet" />
<script src="libs/leaflet-label-0.2.2/leaflet.label.js"></script>
<script src="libs/Proj4Leaflet-0.7.2/proj4-compressed.js"></script>
<script src="libs/Proj4Leaflet-0.7.2/proj4leaflet.js"></script>
<script src="libs/leaflet-binding-1.1.0/leaflet.js"></script>
<script src="libs/leaflet-providers-1.0.27/leaflet-providers.js"></script>
<script src="libs/leaflet-providers-plugin-1.1.0/leaflet-providers-plugin.js"></script>
<link href="libs/leaflet-awesomemarkers-2.0.3/leaflet.awesome-markers.css" rel="stylesheet" />
<script src="libs/leaflet-awesomemarkers-2.0.3/leaflet.awesome-markers.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-99618359-1', 'auto');
  ga('send', 'pageview');

</script>


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="css/style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Geocomputation with R</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Welcome</a><ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#development"><i class="fa fa-check"></i>Development</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#reproducibility"><i class="fa fa-check"></i>Reproducibility</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul>
<li class="chapter" data-level="1.1" data-path="intro.html"><a href="intro.html#what-is-geocomputation"><i class="fa fa-check"></i><b>1.1</b> What is geocomputation?</a></li>
<li class="chapter" data-level="1.2" data-path="intro.html"><a href="intro.html#why-geocomputation-with-r"><i class="fa fa-check"></i><b>1.2</b> Why Geocomputation with R?</a></li>
<li class="chapter" data-level="1.3" data-path="intro.html"><a href="intro.html#software-for-geocomputation"><i class="fa fa-check"></i><b>1.3</b> Software for geocomputation</a></li>
<li class="chapter" data-level="1.4" data-path="intro.html"><a href="intro.html#rs-spatial-ecosystem"><i class="fa fa-check"></i><b>1.4</b> R’s spatial ecosystem</a></li>
<li class="chapter" data-level="1.5" data-path="intro.html"><a href="intro.html#rs-spatial-history"><i class="fa fa-check"></i><b>1.5</b> R’s spatial history</a></li>
<li class="chapter" data-level="1.6" data-path="intro.html"><a href="intro.html#exercises"><i class="fa fa-check"></i><b>1.6</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="spatial-class.html"><a href="spatial-class.html"><i class="fa fa-check"></i><b>2</b> Geographic data in R</a><ul>
<li class="chapter" data-level="" data-path="spatial-class.html"><a href="spatial-class.html#prerequisites"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="2.1" data-path="spatial-class.html"><a href="spatial-class.html#vector-data"><i class="fa fa-check"></i><b>2.1</b> Vector data</a><ul>
<li class="chapter" data-level="2.1.1" data-path="spatial-class.html"><a href="spatial-class.html#intro-sf"><i class="fa fa-check"></i><b>2.1.1</b> An introduction to simple features</a></li>
<li class="chapter" data-level="2.1.2" data-path="spatial-class.html"><a href="spatial-class.html#why-simple-features"><i class="fa fa-check"></i><b>2.1.2</b> Why Simple Features?</a></li>
<li class="chapter" data-level="2.1.3" data-path="spatial-class.html"><a href="spatial-class.html#basic-map"><i class="fa fa-check"></i><b>2.1.3</b> Basic map making</a></li>
<li class="chapter" data-level="2.1.4" data-path="spatial-class.html"><a href="spatial-class.html#sf_classes"><i class="fa fa-check"></i><b>2.1.4</b> Simple feature classes</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="spatial-class.html"><a href="spatial-class.html#raster-data"><i class="fa fa-check"></i><b>2.2</b> Raster data</a><ul>
<li class="chapter" data-level="2.2.1" data-path="spatial-class.html"><a href="spatial-class.html#an-introduction-to-raster"><i class="fa fa-check"></i><b>2.2.1</b> An introduction to raster</a></li>
<li class="chapter" data-level="2.2.2" data-path="spatial-class.html"><a href="spatial-class.html#basic-map-making"><i class="fa fa-check"></i><b>2.2.2</b> Basic map making</a></li>
<li class="chapter" data-level="2.2.3" data-path="spatial-class.html"><a href="spatial-class.html#raster-classes"><i class="fa fa-check"></i><b>2.2.3</b> Raster classes</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="spatial-class.html"><a href="spatial-class.html#crs-intro"><i class="fa fa-check"></i><b>2.3</b> Coordinate Reference Systems</a></li>
<li class="chapter" data-level="2.4" data-path="spatial-class.html"><a href="spatial-class.html#units"><i class="fa fa-check"></i><b>2.4</b> Units</a></li>
<li class="chapter" data-level="2.5" data-path="spatial-class.html"><a href="spatial-class.html#exercises-1"><i class="fa fa-check"></i><b>2.5</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="attr.html"><a href="attr.html"><i class="fa fa-check"></i><b>3</b> Attribute data operations</a><ul>
<li class="chapter" data-level="" data-path="attr.html"><a href="attr.html#prerequisites-1"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="3.1" data-path="attr.html"><a href="attr.html#introduction"><i class="fa fa-check"></i><b>3.1</b> Introduction</a></li>
<li class="chapter" data-level="3.2" data-path="attr.html"><a href="attr.html#vector-attribute-manipulation"><i class="fa fa-check"></i><b>3.2</b> Vector attribute manipulation</a><ul>
<li class="chapter" data-level="3.2.1" data-path="attr.html"><a href="attr.html#vector-attribute-subsetting"><i class="fa fa-check"></i><b>3.2.1</b> Vector attribute subsetting</a></li>
<li class="chapter" data-level="3.2.2" data-path="attr.html"><a href="attr.html#vector-attribute-aggregation"><i class="fa fa-check"></i><b>3.2.2</b> Vector attribute aggregation</a></li>
<li class="chapter" data-level="3.2.3" data-path="attr.html"><a href="attr.html#vector-attribute-joining"><i class="fa fa-check"></i><b>3.2.3</b> Vector attribute joining</a></li>
<li class="chapter" data-level="3.2.4" data-path="attr.html"><a href="attr.html#creating-attributes-and-removing-spatial-information"><i class="fa fa-check"></i><b>3.2.4</b> Creating attributes and removing spatial information</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="attr.html"><a href="attr.html#manipulating-raster-objects"><i class="fa fa-check"></i><b>3.3</b> Manipulating raster objects</a><ul>
<li class="chapter" data-level="3.3.1" data-path="attr.html"><a href="attr.html#raster-subsetting"><i class="fa fa-check"></i><b>3.3.1</b> Raster subsetting</a></li>
<li class="chapter" data-level="3.3.2" data-path="attr.html"><a href="attr.html#summarizing-raster-objects"><i class="fa fa-check"></i><b>3.3.2</b> Summarizing raster objects</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="attr.html"><a href="attr.html#exercises-2"><i class="fa fa-check"></i><b>3.4</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html"><i class="fa fa-check"></i><b>4</b> Spatial data operations</a><ul>
<li class="chapter" data-level="" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#prerequisites-2"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="4.1" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#introduction-1"><i class="fa fa-check"></i><b>4.1</b> Introduction</a></li>
<li class="chapter" data-level="4.2" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#spatial-operations-on-vector-data"><i class="fa fa-check"></i><b>4.2</b> Spatial operations on vector data</a><ul>
<li class="chapter" data-level="4.2.1" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#spatial-subsetting"><i class="fa fa-check"></i><b>4.2.1</b> Spatial subsetting</a></li>
<li class="chapter" data-level="4.2.2" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#topological-relations"><i class="fa fa-check"></i><b>4.2.2</b> Topological relations</a></li>
<li class="chapter" data-level="4.2.3" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#spatial-joining-and-aggregation"><i class="fa fa-check"></i><b>4.2.3</b> Spatial joining and aggregation</a></li>
<li class="chapter" data-level="4.2.4" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#aggregating-or-dissolving"><i class="fa fa-check"></i><b>4.2.4</b> Aggregating or dissolving</a></li>
<li class="chapter" data-level="4.2.5" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#clipping"><i class="fa fa-check"></i><b>4.2.5</b> Clipping</a></li>
<li class="chapter" data-level="4.2.6" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#distance-relations"><i class="fa fa-check"></i><b>4.2.6</b> Distance relations</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#spatial-operations-on-raster-data"><i class="fa fa-check"></i><b>4.3</b> Spatial operations on raster data</a><ul>
<li class="chapter" data-level="4.3.1" data-path="attr.html"><a href="attr.html#raster-subsetting"><i class="fa fa-check"></i><b>4.3.1</b> Spatial subsetting</a></li>
<li class="chapter" data-level="4.3.2" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#map-algebra"><i class="fa fa-check"></i><b>4.3.2</b> Map algebra</a></li>
<li class="chapter" data-level="4.3.3" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#merging-rasters"><i class="fa fa-check"></i><b>4.3.3</b> Merging rasters</a></li>
<li class="chapter" data-level="4.3.4" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#aligning-rasters"><i class="fa fa-check"></i><b>4.3.4</b> Aligning rasters</a></li>
<li class="chapter" data-level="4.3.5" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#exercises-3"><i class="fa fa-check"></i><b>4.3.5</b> Exercises</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="read-write.html"><a href="read-write.html"><i class="fa fa-check"></i><b>5</b> Geographic data I/O</a><ul>
<li class="chapter" data-level="5.1" data-path="read-write.html"><a href="read-write.html#file-formats"><i class="fa fa-check"></i><b>5.1</b> File formats</a></li>
<li class="chapter" data-level="5.2" data-path="read-write.html"><a href="read-write.html#data-input"><i class="fa fa-check"></i><b>5.2</b> Data Input (I)</a><ul>
<li class="chapter" data-level="5.2.1" data-path="read-write.html"><a href="read-write.html#vector-data-1"><i class="fa fa-check"></i><b>5.2.1</b> Vector data</a></li>
<li class="chapter" data-level="5.2.2" data-path="read-write.html"><a href="read-write.html#raster-data-1"><i class="fa fa-check"></i><b>5.2.2</b> Raster data</a></li>
<li class="chapter" data-level="5.2.3" data-path="read-write.html"><a href="read-write.html#data-packages"><i class="fa fa-check"></i><b>5.2.3</b> Data packages</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="read-write.html"><a href="read-write.html#data-output"><i class="fa fa-check"></i><b>5.3</b> Data output (O)</a><ul>
<li class="chapter" data-level="5.3.1" data-path="read-write.html"><a href="read-write.html#vector-data-2"><i class="fa fa-check"></i><b>5.3.1</b> Vector data</a></li>
<li class="chapter" data-level="5.3.2" data-path="read-write.html"><a href="read-write.html#raster-data-2"><i class="fa fa-check"></i><b>5.3.2</b> Raster data</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="read-write.html"><a href="read-write.html#visual-outputs"><i class="fa fa-check"></i><b>5.4</b> Visual outputs</a></li>
<li class="chapter" data-level="5.5" data-path="read-write.html"><a href="read-write.html#exercises-4"><i class="fa fa-check"></i><b>5.5</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i><b>6</b> References</a></li>
<li class="divider"></li>
<li><a href="http://robinlovelace.net/">Robin Lovelace</a></li>
<li><a href="https://nowosad.github.io/">Jakub Nowosad</a></li>
<li><a href="http://www.geographie.uni-jena.de/en/Muenchow.html">Jannes Muenchow</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Geocomputation with R</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="attr" class="section level1">
<h1><span class="header-section-number">3</span> Attribute data operations</h1>
<div id="prerequisites-1" class="section level2 unnumbered">
<h2>Prerequisites</h2>
<ul>
<li>This chapter requires the packages <strong>tidyverse</strong>, <strong>sf</strong> and <strong>raster</strong>:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(sf)
<span class="kw">library</span>(raster)
<span class="kw">library</span>(tidyverse)</code></pre></div>
<ul>
<li>It also relies on <strong>spData</strong>, which loads <code>world</code>, <code>worldbank_df</code> and <code>us_states</code> datasets:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(spData)</code></pre></div>
</div>
<div id="introduction" class="section level2">
<h2><span class="header-section-number">3.1</span> Introduction</h2>
<p>Attribute data is non-spatial information associated with geographic (geometry) data. A bus stop provides a simple example. In a spatial vector object its position would typically be represented by latitude and longitude coordinates (geometry data), in addition to its name. The name is an <em>attribute</em> of the feature (to use Simple Features terminology) that bears no relation to its geometry. <!-- idea: add an example of a bus stop (or modify a previous example so it represents a bus stop) in the previous chapter  --></p>
<p>Another example is the elevation value (attribute) for a specific grid cell in raster data. Unlike vector data, the raster data model stores the coordinate of the grid cell only indirectly: There is a less clear distinction between attribute and spatial information in raster data. Say, we are in the 3<sup>rd</sup> row and the 4<sup>th</sup> column of a raster matrix. To derive the corresponding coordinate, we have to move from the origin three cells in x-direction and four cells in y-direction with the cell resolution defining the distance for each x- and y-step. The raster header gives the matrix a spatial dimension which we need when plotting the raster or when we want to combine two rasters, think, for instance, of adding the values of one raster to another (see also next Chapter). <!-- should we somewhere add a table comparing advantages/disadvantages of using the vector or raster data model, would fit nicely into chapter 2 --></p>
<p>Simple features, described in the previous chapter, store attribute data in a data frame, with each column corresponding to a variable (such as ‘name’) and each row to one observation (such as an individual bus station). In addition, a special column, usually named <code>geom</code> or <code>geometry</code>, stores the geometry data of <strong>sf</strong> objects. For a bus station, that would likely be a single point representing its coordinate of the bus station. By contrast, a line or a polygon consist of multiple points. Still, these points only correspond to one row in the attribute table. This works since <strong>sf</strong> stores the geometry in the form of a list. The list elements correspond to the number of observations in the attribute table. But each list element can contain more than one coordinate if required or even another list as it is the case for polygons with holes (see previous sections). This structure enables multiple columns to represent a range of attributes for thousands of features (one row per feature).</p>
<p>This chapter focuses on non-geographical operations on vector and raster data. For vector data, we will introduce subsetting, aggregating and joining attribute data in the next section. Note that the corresponding functions also have a geographical equivalent. Sometimes you can even use the same functions for attribute and spatial operations. This is the case for subsetting as base R’s <code>[</code> and tidyverse’s <code>filter()</code> let you also subset spatial data based on the spatial extent of another spatial object (see Chapter <a href="spatial-data-operations.html#spatial-data-operations">4</a>). Therefore the skills you learn here are cross-transferable which is also why this chapter lays the foundation for the next chapter (Chapter <a href="spatial-data-operations.html#spatial-data-operations">4</a>) which extends the here presented methods to the spatial world.</p>
<p>Raster attribute data operations are covered in Section <a href="attr.html#manipulating-raster-objects">3.3</a>, which covers the creating continuous and categorical raster layers and extracting cell values from one layer and multiple layers (raster subsetting). Section <a href="attr.html#summarizing-raster-objects">3.3.2</a> provides an overview of ‘global’ raster operations which can be used to characterize entire raster datasets.</p>
</div>
<div id="vector-attribute-manipulation" class="section level2">
<h2><span class="header-section-number">3.2</span> Vector attribute manipulation</h2>
<p><strong>sf</strong> provides support for attribute data associated with vector geometries. Chapter <a href="spatial-class.html#spatial-class">2</a> demonstrated how <code>sf</code> versions of <em>generic methods</em> such as <code>plot()</code> and <code>summary()</code> could be used to explore the basics of vector datasets, of class <code>sf</code>. <strong>sf</strong> also provides methods that allow <code>sf</code> objects to behave like regular data frames:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">methods</span>(<span class="dt">class =</span> <span class="st">&quot;sf&quot;</span>) <span class="co"># methods for sf objects, first 12 shown</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#&gt;  [1] aggregate             cbind                 coerce               </span>
<span class="co">#&gt;  [4] initialize            merge                 plot                 </span>
<span class="co">#&gt;  [7] print                 rbind                 [                    </span>
<span class="co">#&gt; [10] [[&lt;-                  $&lt;-                   show                 </span></code></pre></div>
<p>Many of these functions, including <code>rbind()</code> (for binding rows of data together) and <code>$&lt;-</code> (for creating new columns) were developed for data frames. A key feature of <code>sf</code> objects is that they store spatial and non-spatial data in the same way, as columns in a <code>data.frame</code> (the geometry column is typically called <code>geometry</code>). <code>sf</code> objects also support <code>tibble</code> and <code>tbl</code> classes used in the tidyverse, allowing ‘tidy’ data analysis workflows to apply for spatial data. Thus <strong>sf</strong> enables the full power of R’s data analysis capabilities to be unleashed on geographic data. Before using these capabilities it’s worth re-capping how to discover the basic properties of vector data objects. Let’s start by using base R functions for to get a measure of the <code>world</code> dataset:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dim</span>(world) <span class="co"># it is a 2 dimensional object, with rows and columns</span>
<span class="co">#&gt; [1] 177  11</span>
<span class="kw">nrow</span>(world) <span class="co"># how many rows?</span>
<span class="co">#&gt; [1] 177</span>
<span class="kw">ncol</span>(world) <span class="co"># how many columns?</span>
<span class="co">#&gt; [1] 11</span></code></pre></div>
<p>Our dataset contains ten non-geographical columns (and one geometry list-column) with almost 200 rows representing the world’s countries.</p>
<p>Extracting the attribute data of an <code>sf</code> object is the same as removing its geometry:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world_df =<span class="st"> </span><span class="kw">st_set_geometry</span>(world, <span class="ot">NULL</span>)
<span class="kw">class</span>(world_df)
<span class="co">#&gt; [1] &quot;data.frame&quot;</span></code></pre></div>
<p>This can be useful if the geometry column causes problems, e.g., by occupying large amounts of RAM, or to focus the attention on the attribute data. For most cases, however, there is no harm in keeping the geometry column because non-spatial data operations on <code>sf</code> objects only change an object’s geometry when appropriate (e.g. by disolving borders between adjacent polygons following aggregation). This means that proficiency with attribute data in <code>sf</code> objects equates to proficiency with data frames in R. For many applications, the tidyverse package <strong>dplyr</strong> offers the most effective and intuitive approach of working with data frames, hence the focus on this approach in this section.<a href="#fn19" class="footnoteRef" id="fnref19"><sup>19</sup></a></p>
<div id="vector-attribute-subsetting" class="section level3">
<h3><span class="header-section-number">3.2.1</span> Vector attribute subsetting</h3>
<p>Base R subsetting functions include <code>[</code>, <code>subset()</code> and <code>$</code>. <strong>dplyr</strong> subsetting functions include <code>select()</code>, <code>filter()</code>, and <code>pull()</code>. Both sets of functions preserve the spatial components of attribute data in <code>sf</code> objects.</p>
<p>The <code>[</code> operator can subset both rows and columns. You use indices to specify the elements you wish to extract from an object, e.g., <code>object[i, j]</code>, with <code>i</code> and <code>j</code> typically being numbers or logical vectors — <code>TRUE</code>s and <code>FALSE</code>s — representing rows and columns (they can also be character strings, indicating row or column names). <!-- you can also use `[`(world, 1:6, 1) --> Leaving <code>i</code> or <code>j</code> empty returns all rows or columns, so <code>world[1:5, ]</code> returns the first five rows and all columns. The examples below demonstrate subsetting with base R. The results are not shown; check the results on your own computer:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world[<span class="dv">1</span>:<span class="dv">6</span>, ] <span class="co"># subset rows by position</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world[, <span class="dv">1</span>:<span class="dv">3</span>] <span class="co"># subset columns by position</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world[, <span class="kw">c</span>(<span class="st">&quot;name_long&quot;</span>, <span class="st">&quot;lifeExp&quot;</span>)] <span class="co"># subset columns by name</span></code></pre></div>
<p>A demonstration of the utility of using <code>logical</code> vectors for subsetting is shown in the code chunk below. This creates a new object, <code>small_countries</code>, containing nations whose surface area is smaller than 100,000 km<sup>2</sup>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sel_area =<span class="st"> </span>world$area_km2 &lt;<span class="st"> </span><span class="dv">10000</span>
<span class="kw">summary</span>(sel_area) <span class="co"># a logical vector</span>
<span class="co">#&gt;    Mode   FALSE    TRUE </span>
<span class="co">#&gt; logical     170       7</span>
small_countries =<span class="st"> </span>world[sel_area, ]</code></pre></div>
<p>The intermediary <code>sel_object</code> is a logical vector that shows that only seven countries match the query. A more concise command, that omits the intermediary object, generates the same result:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">small_countries =<span class="st"> </span>world[world$area_km2 &lt;<span class="st"> </span><span class="dv">10000</span>, ]</code></pre></div>
<p>Another the base R function <code>subset()</code> provides yet another way to achieve the same result:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">small_countries =<span class="st"> </span><span class="kw">subset</span>(world, area_km2 &lt;<span class="st"> </span><span class="dv">10000</span>)</code></pre></div>
<p>You can use the <code>$</code> operator to select a specific variable by its name. The result is a vector:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world$name_long</code></pre></div>
<!-- , after the package has been loaded: [or - it is a part of tidyverse] -->
<p>Base R functions are essential, and we recommend that you have a working knowledge of them. However, <strong>dplyr</strong> can make working with data frames more intuitive, and can lead to faster code due to its C++ backend and ability to interface with data bases (important when working with big data). The main <strong>dplyr</strong> subsetting functions are <code>select()</code>, <code>slice()</code>, <code>filter()</code> and <code>pull()</code>.</p>
<div class="rmdnote">
<p>
Both <strong>raster</strong> and <strong>dplyr</strong> packages have a function called <code>select()</code>. If both packages are loaded, this can generate error messages containing the text: <code>unable to find an inherited method for function ‘select’ for signature ‘“sf”’</code>. To avoid this error message, and prevent ambiguity, we use the long-form function name, prefixed by the package name and two colons (usually omitted from R scripts for concise code): <code>dplyr::select()</code>.
</p>
</div>
<p><code>select()</code> selects columns by name or position. For example, you could select only two columns, <code>name_long</code> and <code>pop</code>, with the following command (note the <code>geom</code> column remains):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world1 =<span class="st"> </span>dplyr::<span class="kw">select</span>(world, name_long, pop)
<span class="kw">names</span>(world1)
<span class="co">#&gt; [1] &quot;name_long&quot; &quot;pop&quot;       &quot;geom&quot;</span></code></pre></div>
<p><code>select()</code> also allows subsetting of a range of columns with the help of the <code>:</code> operator:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># all columns between name_long and pop (inclusive)</span>
world2 =<span class="st"> </span>dplyr::<span class="kw">select</span>(world, name_long:pop)</code></pre></div>
<p>Omit specific columns with the <code>-</code> operator:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># all columns except subregion and area_km2 (inclusive)</span>
world3 =<span class="st"> </span>dplyr::<span class="kw">select</span>(world, -subregion, -area_km2)</code></pre></div>
<p>Conveniently, <code>select()</code> lets you subset and rename columns at the same time, for example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world4 =<span class="st"> </span>dplyr::<span class="kw">select</span>(world, name_long, <span class="dt">population =</span> pop)
<span class="kw">names</span>(world4)
<span class="co">#&gt; [1] &quot;name_long&quot;  &quot;population&quot; &quot;geom&quot;</span></code></pre></div>
<p>This is more concise than the base R equivalent:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world5 =<span class="st"> </span>world[, <span class="kw">c</span>(<span class="st">&quot;name_long&quot;</span>, <span class="st">&quot;pop&quot;</span>)] <span class="co"># subset columns by name</span>
<span class="kw">names</span>(world5)[<span class="dv">2</span>] =<span class="st"> &quot;population&quot;</span> <span class="co"># rename column manually</span></code></pre></div>
<p><code>select()</code> also works with ‘helper functions’ for advanced subsetting operations, including <code>contains()</code>, <code>starts_with()</code> and <code>num_range()</code> (see the help page with <code>?select</code> for details).</p>
<p><code>slice()</code> is the row-equivalent of <code>select()</code>. The following code chunk, for example, selects the 3<sup>rd</sup> to 5<sup>th</sup> rows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">slice</span>(world, <span class="dv">3</span>:<span class="dv">5</span>)</code></pre></div>
<p><code>filter()</code> is <strong>dplyr</strong>’s equivalent of base R’s <code>subset()</code> function. It keeps only rows matching given criteria, e.g., only countries with a very high average of life expectancy:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># only countries with a life expectation larger than 82 years</span>
world6 =<span class="st"> </span><span class="kw">filter</span>(world, lifeExp &gt;<span class="st"> </span><span class="dv">82</span>)</code></pre></div>
<p>The standard set of comparison operators can be used in the <code>filter()</code> function, as illustrated in Table <a href="attr.html#tab:operators">3.1</a>:</p>
<table>
<caption><span id="tab:operators">Table 3.1: </span>Table of comparison operators that result in boolean (TRUE/FALSE) outputs.</caption>
<thead>
<tr class="header">
<th align="left">Symbol</th>
<th align="left">Name</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>==</code></td>
<td align="left">Equal to</td>
</tr>
<tr class="even">
<td align="left"><code>!=</code></td>
<td align="left">Not equal to</td>
</tr>
<tr class="odd">
<td align="left"><code>&gt;, &lt;</code></td>
<td align="left">Greater/Less than</td>
</tr>
<tr class="even">
<td align="left"><code>&gt;=, &lt;=</code></td>
<td align="left">Greater/Less than or equal</td>
</tr>
<tr class="odd">
<td align="left"><code>&amp;, |, !</code></td>
<td align="left">Logical operators: And, Or, Not</td>
</tr>
</tbody>
</table>
<!-- describe these: ==, !=, >, >=, <, <=, &, | -->
<!-- add warning about = vs == -->
<!-- add info about combination of &, |, ! -->
<p>Another benefit of <strong>dplyr</strong> is its ease of use. This is greatly enhanced by its compatibility with the <em>pipe</em> operator <code>%&gt;%</code> (from <strong>magrittr</strong>), which takes its name from the Unix pipe <code>|</code>. Despite its strange form (it points ‘forward’), its behaviour is simple, ‘piping’ the output of a previous command into the first argument of the next function. Many functions can be combined in this way in a process called <em>chaining</em>, illustrated below. This code chunk takes the <code>world</code> dataset, selects the columns <code>name_long</code> and <code>continent</code>, and returns the first five rows (result not shown).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world %&gt;%
<span class="st">  </span>dplyr::<span class="kw">select</span>(name_long, continent) %&gt;%
<span class="st">  </span><span class="kw">slice</span>(<span class="dv">1</span>:<span class="dv">5</span>)</code></pre></div>
<p>The pipe operator supports an intuitive data analysis workflow. It allows operations to be written in a clear order, line-by-line and from left to right (as with most languages), avoiding ‘nesting’, whereby one function is buried inside another (without pipes the code in the previous chunk would be written as <code>slice(select(world, name_long, continent), 1:5)</code> which is harder for most people to read, write and understand). Another advantage over the nesting approach is that you can easily comment out certain parts of a pipe. <strong>dplyr</strong> works especially well with the pipe operator because its fundamental functions (or ‘verbs’, like <code>select()</code>) expect a data frame object as input and also return one.<a href="#fn20" class="footnoteRef" id="fnref20"><sup>20</sup></a></p>
</div>
<div id="vector-attribute-aggregation" class="section level3">
<h3><span class="header-section-number">3.2.2</span> Vector attribute aggregation</h3>
<p>Aggregation operations summarize datasets by a grouping variable, which can be either another attribute column or a spatial object (see Chapter <a href="#spatial-attribute-operations"><strong>??</strong></a>). Imagine we would like to calculate the number of people per continent. Fortunately, our <code>world</code> dataset has the necessary ingredients, with the <code>pop</code> column containing the population per country and <code>continent</code> the continent. This allows us to aggregate populations per country using the continent column as a grouping variable. In base R this is done with <code>aggregate()</code>, which requires the grouping variable to be a <code>list</code> object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ag_var =<span class="st"> </span><span class="kw">list</span>(world$continent)
<span class="kw">aggregate</span>(world$pop, <span class="dt">by =</span> ag_var, <span class="dt">FUN =</span> sum, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p>This leaves us with a table with eight rows representing the number of inhabitants for each of the continents (see Table <a href="attr.html#tab:continents">3.2</a> with results for the top 3 most populous continents). <code>summarize()</code> is the <strong>dplyr</strong> equivalent of <code>aggregate()</code>. To specify groups, you will need also the <code>group_by()</code> command. So obtaining the exact same result as above, you need to type <code>group_by(world, continent) %&gt;% summarize(pop = sum(pop, na.rm = TRUE))</code>. If we leave the grouping variable unspecified, we simply retrieve the total, in our case the number of people living on Earth:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># customized data summary</span>
world %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">st_set_geometry</span>(<span class="ot">NULL</span>) %&gt;%
<span class="st">  </span><span class="kw">summarize</span>(<span class="dt">pop =</span> <span class="kw">sum</span>(pop, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>), <span class="dt">n_countries =</span> <span class="kw">n</span>())
<span class="co">#&gt;        pop n_countries</span>
<span class="co">#&gt; 1 7.21e+09         177</span>
<span class="co"># A total population &gt; 7 billion</span></code></pre></div>
<p>The new object, <code>world_summary</code>, is an aggregation of all 177 world’s countries. It consists of one row and two columns. The <code>pop =</code> and <code>n_countries =</code> created the names of the two columns, while the <code>sum()</code>- and <code>n()</code>-function actually did the aggregation. The first function added up all inhabitants, while the latter simply counted the number of rows.</p>
<p>You can use a wide range of functions within <code>summarize()</code> for aggregation and summary purposes. Type <code>?summarize</code> for a list with useful functions and more information (see Chapter 5 of <a href="http://r4ds.had.co.nz/transform.html#grouped-summaries-with-summarize">R for Data Science</a> for a more detailed overview of <code>summarize()</code>),</p>
<table>
<caption><span id="tab:continents">Table 3.2: </span>The top 3 most populous continents, and the number of countries in each.</caption>
<thead>
<tr class="header">
<th align="left">iso_a2</th>
<th align="left">name_long</th>
<th align="left">continent</th>
<th align="left">region_un</th>
<th align="left">subregion</th>
<th align="left">type</th>
<th align="right">area_km2</th>
<th align="right">pop</th>
<th align="right">lifeExp</th>
<th align="right">gdpPercap</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">CN</td>
<td align="left">China</td>
<td align="left">Asia</td>
<td align="left">Asia</td>
<td align="left">Eastern Asia</td>
<td align="left">Country</td>
<td align="right">9409832</td>
<td align="right">1.36e+09</td>
<td align="right">75.8</td>
<td align="right">12759</td>
</tr>
<tr class="even">
<td align="left">IN</td>
<td align="left">India</td>
<td align="left">Asia</td>
<td align="left">Asia</td>
<td align="left">Southern Asia</td>
<td align="left">Sovereign country</td>
<td align="right">3142892</td>
<td align="right">1.30e+09</td>
<td align="right">68.0</td>
<td align="right">5392</td>
</tr>
<tr class="odd">
<td align="left">US</td>
<td align="left">United States</td>
<td align="left">North America</td>
<td align="left">Americas</td>
<td align="left">Northern America</td>
<td align="left">Country</td>
<td align="right">9510744</td>
<td align="right">3.19e+08</td>
<td align="right">78.9</td>
<td align="right">51775</td>
</tr>
</tbody>
</table>
<p><code>sf</code> objects are well-integrated with the <strong>tidyverse</strong>, as illustrated by the fact that the aggregated objects preserve the geometry of the original <code>world</code> object. Here, we even had to make some efforts to prevent a spatial operation. When <code>aggregate()</code>ing the population we have just used the population vector. Had we used the spatial object (world[, “population”]), <code>aggregate()</code> would have done a spatial aggregation of the polygon data. The same would have happened, had we not dismissed the geometry prior to using the <code>summarize()</code> function. We will explain this so-called ‘dissolving polygons’ in more detail in the the next chapter.</p>
<!-- Todo (optional): add exercise exploring similarities/differences with `world_continents`? -->
<!-- should it stay or should it go (?) aka should we present the arrange function?: -->
<!-- Jannes: I would suggest to leave the arrange function as an exercise to the reader. -->
<!-- ```{r} -->
<!-- # sort variables -->
<!-- ## by name -->
<!-- world_continents %>%  -->
<!--   arrange(continent) -->
<!-- ## by population (in descending order) -->
<!-- world_continents %>%  -->
<!--   arrange(-pop) -->
<!-- ``` -->
</div>
<div id="vector-attribute-joining" class="section level3">
<h3><span class="header-section-number">3.2.3</span> Vector attribute joining</h3>
<!-- https://github.com/dgrtwo/fuzzyjoin -->
<!-- http://r4ds.had.co.nz/relational-data.html -->
<!-- non-unique keys -->
<p>Combining data from different sources is one of the most common tasks in data preparation. Joins are methods to combine pair of tables based on a shared key variable. The <strong>dplyr</strong> package has a set of verbs to easily join <code>data.frames</code> - <code>left_join()</code>, <code>right_join()</code>, <code>inner_join()</code>, <code>full_join</code>, <code>semi_join()</code> and <code>anti_join()</code>. These function names follow conventions used in the database language SQL, as explained in <a href="http://r4ds.had.co.nz/relational-data.html">Chapter 13</a> of <em>R for Data Science</em> <span class="citation">(Grolemund and Wickham <a href="#ref-grolemund_r_2016">2016</a>)</span>.</p>
<p>Working with spatial data, however, usually involves a connection between spatial data (<code>sf</code> objects) and tables (<code>data.frame</code> objects). Fortunately, the <strong>sf</strong> package has all of the <strong>dplyr</strong> join functions adapted to work with <code>sf</code> objects. The only important difference between combining two <code>data.frames</code> and combining <code>sf</code> and <code>data.frame</code> objects is the special <code>sf</code> column storing the geometry information. Therefore, the result of data joins can be either an <code>sf</code> or <code>data.frame</code> object.</p>
<p>Most joins involving spatial data will have an <code>sf</code> object as the first argument and a <code>data.frame</code> object as the second argument, resulting in a new <code>sf</code> object (the reverse order is also possible and will return a <code>data.frame</code>). We will focus on the commonly used left and inner joins, which use the same syntax as the other join types <span class="citation">(see Grolemund and Wickham <a href="#ref-grolemund_r_2016">2016</a> for more join types)</span>.</p>
<p>The easiest way to understand the concept of joins is to show how they work with a smaller dataset. We will use an <code>sf</code> object <code>north_america</code> with country codes (<code>iso_a2</code>), names and geometries, as well as a <code>data.frame</code> object <code>wb_north_america</code> containing information about urban population and unemployment for three countries. Note that <code>north_america</code> contains data about Canada, Greenland and the United States but the World Bank dataset (<code>wb_north_america</code>) contains information about Canada, Mexico and the United States:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">north_america =<span class="st"> </span>world %&gt;%
<span class="st">  </span><span class="kw">filter</span>(subregion ==<span class="st"> &quot;Northern America&quot;</span>) %&gt;%
<span class="st">  </span>dplyr::<span class="kw">select</span>(iso_a2, name_long)
north_america$name_long
<span class="co">#&gt; [1] &quot;Canada&quot;        &quot;Greenland&quot;     &quot;United States&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">wb_north_america =<span class="st"> </span>worldbank_df %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(name %in%<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Canada&quot;</span>, <span class="st">&quot;Mexico&quot;</span>, <span class="st">&quot;United States&quot;</span>)) %&gt;%
<span class="st">  </span>dplyr::<span class="kw">select</span>(name, iso_a2, urban_pop, <span class="dt">unemploy =</span> unemployment)</code></pre></div>
<p>We will use a left join to combine the two datasets. Left joins are the most commonly used operation for adding attributes to spatial data, as they return all observations from the left object (<code>north_america</code>) and the matched observations from the right object (<code>wb_north_america</code>) in new columns. Rows in the left object without matches in the right (<code>Greenland</code> in this case) result in <code>NA</code> values.</p>
<p>To join two objects we need to specify a key. This is a variable (or a set of variables) that uniquely identifies each observation (row). The <code>by</code> argument of <strong>dplyr</strong>’s join functions lets you identify the key variable. In simple cases, a single, unique variable exist in both objects like the <code>iso_a2</code> column in our example (you may need to rename columns with identifying information for this to work):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">left_join1 =<span class="st"> </span>north_america %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">left_join</span>(wb_north_america, <span class="dt">by =</span> <span class="st">&quot;iso_a2&quot;</span>)</code></pre></div>
<p>This has created a spatial dataset with the new variables added. The utility of this is shown in Figure <a href="attr.html#fig:unemploy">3.1</a>, which shows the unemployment rate (a World Bank variable) across the countries of North America.</p>
<div class="figure" style="text-align: center"><span id="fig:unemploy"></span>
<img src="figures/unemploy-1.png" alt="The unemployment rate (taken from World Bank statistics) in Canada and the United States to illustrate the utility of joining attribute data on to spatial datasets." width="576" />
<p class="caption">
Figure 3.1: The unemployment rate (taken from World Bank statistics) in Canada and the United States to illustrate the utility of joining attribute data on to spatial datasets.
</p>
</div>
<p>It is also possible to join objects by different variables. Both of the datasets have variables with names of countries, but they are named differently. The <code>north_america</code> has a <code>name_long</code> column and the <code>wb_north_america</code> has a <code>name</code> column. In these cases, we can use a named vector to specify the connection, e.g. <code>c(&quot;name_long&quot; = &quot;name&quot;)</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">left_join2 =<span class="st"> </span>north_america %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">left_join</span>(wb_north_america, <span class="dt">by =</span> <span class="kw">c</span>(<span class="st">&quot;name_long&quot;</span> =<span class="st"> &quot;name&quot;</span>))
left_join2
<span class="co">#&gt; Simple feature collection with 3 features and 5 fields</span>
<span class="co">#&gt; geometry type:  MULTIPOLYGON</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: -171.7911 ymin: 18.91619 xmax: -12.20855 ymax: 83.64513</span>
<span class="co">#&gt; epsg (SRID):    4326</span>
<span class="co">#&gt; proj4string:    +proj=longlat +datum=WGS84 +no_defs</span>
<span class="co">#&gt;   iso_a2.x     name_long iso_a2.y urban_pop unemploy</span>
<span class="co">#&gt; 1       CA        Canada       CA  29022137     6.91</span>
<span class="co">#&gt; 2       GL     Greenland     &lt;NA&gt;        NA       NA</span>
<span class="co">#&gt; 3       US United States       US 259740511     6.17</span>
<span class="co">#&gt;                             geom</span>
<span class="co">#&gt; 1 MULTIPOLYGON (((-63.6645 46...</span>
<span class="co">#&gt; 2 MULTIPOLYGON (((-46.76379 8...</span>
<span class="co">#&gt; 3 MULTIPOLYGON (((-155.54211 ...</span></code></pre></div>
<p>The new object <code>left_join2</code>, however, contains two duplicated variables - <code>iso_a2.x</code> and <code>iso_a2.y</code> because both of the input tables possessed a variable named <code>iso_a2</code>. To solve this problem we should specify all the keys:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">left_join3 =<span class="st"> </span>north_america %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">left_join</span>(wb_north_america, <span class="dt">by =</span> <span class="kw">c</span>(<span class="st">&quot;iso_a2&quot;</span>, <span class="st">&quot;name_long&quot;</span> =<span class="st"> &quot;name&quot;</span>))
left_join3
<span class="co">#&gt; Simple feature collection with 3 features and 4 fields</span>
<span class="co">#&gt; geometry type:  MULTIPOLYGON</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: -171.7911 ymin: 18.91619 xmax: -12.20855 ymax: 83.64513</span>
<span class="co">#&gt; epsg (SRID):    4326</span>
<span class="co">#&gt; proj4string:    +proj=longlat +datum=WGS84 +no_defs</span>
<span class="co">#&gt;   iso_a2     name_long urban_pop unemploy                           geom</span>
<span class="co">#&gt; 1     CA        Canada  29022137     6.91 MULTIPOLYGON (((-63.6645 46...</span>
<span class="co">#&gt; 2     GL     Greenland        NA       NA MULTIPOLYGON (((-46.76379 8...</span>
<span class="co">#&gt; 3     US United States 259740511     6.17 MULTIPOLYGON (((-155.54211 ...</span></code></pre></div>
<p>It is also possible to use our objects in the reverse order, where a <code>data.frame</code> object is the first argument and a <code>sf</code> object is the second argument. This would keep the geometry column but drop the <code>sf</code> class, and result in a <code>data.frame</code> object.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># keeps the geom column, but drops the sf class</span>
left_join4 =<span class="st"> </span>wb_north_america %&gt;%
<span class="st">  </span><span class="kw">left_join</span>(north_america, <span class="dt">by =</span> <span class="kw">c</span>(<span class="st">&quot;iso_a2&quot;</span>))
left_join4
<span class="co">#&gt;            name iso_a2 urban_pop unemploy     name_long</span>
<span class="co">#&gt; 1        Canada     CA  29022137     6.91        Canada</span>
<span class="co">#&gt; 2        Mexico     MX  99018446     5.25          &lt;NA&gt;</span>
<span class="co">#&gt; 3 United States     US 259740511     6.17 United States</span>
<span class="co">#&gt;                             geom</span>
<span class="co">#&gt; 1 MULTIPOLYGON (((-63.6645 46...</span>
<span class="co">#&gt; 2                           NULL</span>
<span class="co">#&gt; 3 MULTIPOLYGON (((-155.54211 ...</span>
<span class="kw">class</span>(left_join4)
<span class="co">#&gt; [1] &quot;data.frame&quot;</span></code></pre></div>
<p><code>left_join4</code> has only one class - <code>data.frame</code>, however it is possible to add spatial <code>sf</code> class using the <code>st_as_sf()</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">left_join4_sf =<span class="st"> </span><span class="kw">st_as_sf</span>(left_join4)
left_join4_sf
<span class="co">#&gt; Simple feature collection with 3 features and 5 fields (with 1 geometry empty)</span>
<span class="co">#&gt; geometry type:  MULTIPOLYGON</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: -171.7911 ymin: 18.91619 xmax: -52.6481 ymax: 83.23324</span>
<span class="co">#&gt; epsg (SRID):    4326</span>
<span class="co">#&gt; proj4string:    +proj=longlat +datum=WGS84 +no_defs</span>
<span class="co">#&gt;            name iso_a2 urban_pop unemploy     name_long</span>
<span class="co">#&gt; 1        Canada     CA  29022137     6.91        Canada</span>
<span class="co">#&gt; 2        Mexico     MX  99018446     5.25          &lt;NA&gt;</span>
<span class="co">#&gt; 3 United States     US 259740511     6.17 United States</span>
<span class="co">#&gt;                             geom</span>
<span class="co">#&gt; 1 MULTIPOLYGON (((-63.6645 46...</span>
<span class="co">#&gt; 2             MULTIPOLYGON EMPTY</span>
<span class="co">#&gt; 3 MULTIPOLYGON (((-155.54211 ...</span>
<span class="kw">class</span>(left_join4_sf)
<span class="co">#&gt; [1] &quot;sf&quot;         &quot;data.frame&quot;</span></code></pre></div>
<p>On the other hand, it is also possible to remove the geometry column of <code>left_join4</code> using base R functions or <code>dplyr</code>. Here, this is this simple because the geometry column is just another <code>data.frame</code> column and no longer the sticky geometry column of an <code>sf</code> object (see also Chapter <a href="spatial-class.html#spatial-class">2</a>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># base R</span>
left_join4_df =<span class="st"> </span><span class="kw">subset</span>(left_join4, <span class="dt">select =</span> -geom)
<span class="co"># or dplyr</span>
left_join4_df =<span class="st"> </span>left_join4 %&gt;%<span class="st"> </span>dplyr::<span class="kw">select</span>(-geom)
left_join4_df
<span class="co">#&gt;            name iso_a2 urban_pop unemploy     name_long</span>
<span class="co">#&gt; 1        Canada     CA  29022137     6.91        Canada</span>
<span class="co">#&gt; 2        Mexico     MX  99018446     5.25          &lt;NA&gt;</span>
<span class="co">#&gt; 3 United States     US 259740511     6.17 United States</span>
<span class="kw">class</span>(left_join4_df)
<span class="co">#&gt; [1] &quot;data.frame&quot;</span></code></pre></div>
<p>In contrast to the left join, the <code>inner_join()</code> keeps only observations from the left object (<code>north_america</code>) where there are matching observations in the right object (<code>wb_north_america</code>). Additionally, all columns from the left and right object are kept:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">inner_join1 =<span class="st"> </span>north_america %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">inner_join</span>(wb_north_america, <span class="dt">by =</span> <span class="kw">c</span>(<span class="st">&quot;iso_a2&quot;</span>, <span class="st">&quot;name_long&quot;</span> =<span class="st"> &quot;name&quot;</span>))
inner_join1
<span class="co">#&gt; Simple feature collection with 2 features and 4 fields</span>
<span class="co">#&gt; geometry type:  MULTIPOLYGON</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: -171.7911 ymin: 18.91619 xmax: -52.6481 ymax: 83.23324</span>
<span class="co">#&gt; epsg (SRID):    4326</span>
<span class="co">#&gt; proj4string:    +proj=longlat +datum=WGS84 +no_defs</span>
<span class="co">#&gt;   iso_a2     name_long urban_pop unemploy                           geom</span>
<span class="co">#&gt; 1     CA        Canada  29022137     6.91 MULTIPOLYGON (((-63.6645 46...</span>
<span class="co">#&gt; 2     US United States 259740511     6.17 MULTIPOLYGON (((-155.54211 ...</span></code></pre></div>
</div>
<div id="creating-attributes-and-removing-spatial-information" class="section level3">
<h3><span class="header-section-number">3.2.4</span> Creating attributes and removing spatial information</h3>
<!-- lubridate? -->
<p>Often, we would like to create a new column based on already existing columns. For example, we want to calculate population density for each country. For this we need to divide a population column, here <code>pop</code>, by an area column , here <code>area_km2</code> with unit area in square km. Using base R, we can type:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(<span class="st">&quot;world&quot;</span>)
world_new =<span class="st"> </span>world <span class="co"># do not overwrite our original data</span>
world_new$pop_dens =<span class="st"> </span>world_new$pop /<span class="st"> </span>world_new$area_km2</code></pre></div>
<p>Alternatively, we can use one of <strong>dplyr</strong> functions - <code>mutate()</code> or <code>transmute()</code>. <code>mutate()</code> adds new columns at the penultimate position in the <code>sf</code> object (the last one is reserved for the geometry):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">pop_dens =</span> pop /<span class="st"> </span>area_km2)</code></pre></div>
<p>The difference between <code>mutate()</code> and <code>transmute()</code> is that the latter skips all other existing columns (except for the sticky geometry column):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">transmute</span>(<span class="dt">pop_dens =</span> pop /<span class="st"> </span>area_km2)</code></pre></div>
<p>Existing columns could be also paste together using <code>unite()</code>. For example, we want to stick together <code>continent</code> and <code>region_un</code> columns into a new <code>con_reg</code> column. We could specify a separator to use between values and if input columns should be removed:</p>
<!-- todo: set eval = TRUE when travis issue resolved -->
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world_unite =<span class="st"> </span>world %&gt;%
<span class="st">  </span><span class="kw">unite</span>(<span class="st">&quot;con_reg&quot;</span>, continent:region_un, <span class="dt">sep =</span> <span class="st">&quot;:&quot;</span>, <span class="dt">remove =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p>The <code>separate()</code> function is the complement of the <code>unite()</code> function. Its role is to split one column into multiple columns using either a regular expression or character position.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world_separate =<span class="st"> </span>world_unite %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(con_reg, <span class="kw">c</span>(<span class="st">&quot;continent&quot;</span>, <span class="st">&quot;region_un&quot;</span>), <span class="dt">sep =</span> <span class="st">&quot;:&quot;</span>)</code></pre></div>
<p>Two helper functions, <code>rename()</code> and <code>set_names</code> can be used to change columns names. The first one, <code>rename()</code> replace an old name with a new one. For example, we want to change a name of column from <code>name_long</code> to <code>name</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">rename</span>(<span class="dt">name =</span> name_long)</code></pre></div>
<p><code>set_names</code> can be used to change names of many columns. In this function, we do not need to provide old names:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">new_names =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;ISO_A2&quot;</span>, <span class="st">&quot;Name&quot;</span>, <span class="st">&quot;Continent&quot;</span>, <span class="st">&quot;Region&quot;</span>, <span class="st">&quot;Subregion&quot;</span>, 
              <span class="st">&quot;Country_type&quot;</span>, <span class="st">&quot;Area_in_km2&quot;</span>, <span class="st">&quot;Population&quot;</span>, <span class="st">&quot;Life_Expectancy&quot;</span>,
              <span class="st">&quot;GDP_per_capita&quot;</span>, <span class="st">&quot;geom&quot;</span>)
world %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">set_names</span>(new_names)</code></pre></div>
<p>It is important to note that the attribute data operations preserve the geometry of the simple features. As mentioned at the outset of the chapter, however, it can be useful to remove the geometry. Do do this, you have to explicitly remove it because <code>sf</code> explicitly makes the geometry column sticky. This behavior ensures that data frame operations do not accidentally remove the geometry column. Hence, an approach such as <code>select(world, -geom)</code> will be unsuccessful instead use <code>st_set_geometry()</code><a href="#fn21" class="footnoteRef" id="fnref21"><sup>21</sup></a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world_data =<span class="st"> </span>world %&gt;%<span class="st"> </span><span class="kw">st_set_geometry</span>(<span class="ot">NULL</span>)
<span class="kw">class</span>(world_data)
<span class="co">#&gt; [1] &quot;data.frame&quot;</span></code></pre></div>
</div>
</div>
<div id="manipulating-raster-objects" class="section level2">
<h2><span class="header-section-number">3.3</span> Manipulating raster objects</h2>
<p>In contrast to simple features (vector data), raster data represents continuous surfaces. In this section we will use a raster object created <em>from scratch</em>, building on section <a href="spatial-class.html#an-introduction-to-raster">2.2.1</a>. Raster data has a fundamentally different structure than vector data, so subsetting and other operations work in a different way, as demonstrated in section <a href="attr.html#raster-subsetting">3.3.1</a>.</p>
<p>Let us start with manually recreating the raster dataset of Chapter <a href="spatial-class.html#raster-classes">2.2.3</a>. This should make it easy to understand how <strong>raster</strong> and related operations work (Figure <a href="attr.html#fig:cont-cate-rasters">3.2</a>). Here, we create a raster which should represent elevations, therefore, we name it accordingly <code>elev</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(raster)
elev =<span class="st"> </span><span class="kw">raster</span>(<span class="dt">nrow =</span> <span class="dv">6</span>, <span class="dt">ncol =</span> <span class="dv">6</span>, <span class="dt">res =</span> <span class="fl">0.5</span>,
              <span class="dt">xmn =</span> -<span class="fl">1.5</span>, <span class="dt">xmx =</span> <span class="fl">1.5</span>, <span class="dt">ymn =</span> -<span class="fl">1.5</span>, <span class="dt">ymx =</span> <span class="fl">1.5</span>,
              <span class="dt">vals =</span> <span class="dv">1</span>:<span class="dv">36</span>)</code></pre></div>
<p>Note that a raster object can also contain categorical data. For this, we can use either Boolean or factor variables in R. For instance, we can create a raster representing grain sizes (Figure <a href="attr.html#fig:cont-cate-rasters">3.2</a>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">grain_size =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;clay&quot;</span>, <span class="st">&quot;silt&quot;</span>, <span class="st">&quot;sand&quot;</span>)
grain =<span class="st"> </span><span class="kw">raster</span>(<span class="dt">nrow =</span> <span class="dv">6</span>, <span class="dt">ncol =</span> <span class="dv">6</span>, <span class="dt">res =</span> <span class="fl">0.5</span>, 
               <span class="dt">xmn =</span> -<span class="fl">1.5</span>, <span class="dt">xmx =</span> <span class="fl">1.5</span>, <span class="dt">ymn =</span> -<span class="fl">1.5</span>, <span class="dt">ymx =</span> <span class="fl">1.5</span>,
               <span class="dt">vals =</span> <span class="kw">factor</span>(<span class="kw">sample</span>(grain_size, <span class="dv">36</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>), 
                             <span class="dt">levels =</span> grain_size))
grain
<span class="co">#&gt; class       : RasterLayer </span>
<span class="co">#&gt; dimensions  : 6, 6, 36  (nrow, ncol, ncell)</span>
<span class="co">#&gt; resolution  : 0.5, 0.5  (x, y)</span>
<span class="co">#&gt; extent      : -1.5, 1.5, -1.5, 1.5  (xmin, xmax, ymin, ymax)</span>
<span class="co">#&gt; coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0 </span>
<span class="co">#&gt; data source : in memory</span>
<span class="co">#&gt; names       : layer </span>
<span class="co">#&gt; values      : 1, 3  (min, max)</span>
<span class="co">#&gt; attributes  :</span>
<span class="co">#&gt;  ID VALUE</span>
<span class="co">#&gt;   1  clay</span>
<span class="co">#&gt;   2  silt</span>
<span class="co">#&gt;   3  sand</span></code></pre></div>
<p>The <strong>raster</strong> package represents Boolean and factor variables as integers. Hence, <code>grain[1, 1]</code> returns an integer instead of “sand”, “silt” or “clay”. These integers in turn represent unique identifiers. The raster object stores the corresponding look-up table or “Raster Attribute Table” (RAT) as a data frame in a new slot named <code>attributes</code> which you see when you print a so-called ‘ratified’ raster to the console (see the help page of the <code>ratify()</code> command for more information). Use <code>levels()</code> to just retrieve the attribute table. We can even add further columns to this attribute table:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">levels</span>(grain)[[<span class="dv">1</span>]] =<span class="st">  </span><span class="kw">cbind</span>(<span class="kw">levels</span>(grain)[[<span class="dv">1</span>]], <span class="dt">wetness =</span> <span class="kw">c</span>(<span class="st">&quot;wet&quot;</span>, <span class="st">&quot;moist&quot;</span>, <span class="st">&quot;dry&quot;</span>))
<span class="kw">levels</span>(grain)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt;   ID VALUE wetness</span>
<span class="co">#&gt; 1  1  clay     wet</span>
<span class="co">#&gt; 2  2  silt   moist</span>
<span class="co">#&gt; 3  3  sand     dry</span></code></pre></div>
<p>This is really interesting since we have learned that each raster cell can only possess one value. In fact, the raster cells themselves still consist of only one value, namely an integer which represents a unique identifier. This identifier can then be used to look up the attributes in the corresponding attribute table (stored in a slot named <code>attributes</code>). Say, we would like to know the grain size and the wetness of cell IDs 1, 12 and 36, we can run:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">factorValues</span>(grain, grain[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">12</span>, <span class="dv">36</span>)])
<span class="co">#&gt;   VALUE wetness</span>
<span class="co">#&gt; 1  sand     dry</span>
<span class="co">#&gt; 2  clay     wet</span>
<span class="co">#&gt; 3  silt   moist</span></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:cont-cate-rasters"></span>
<img src="figures/03_cont_categ_rasters.png" alt="Raster with numberic values (left) and a raster with categorical values (right)." width="765" />
<p class="caption">
Figure 3.2: Raster with numberic values (left) and a raster with categorical values (right).
</p>
</div>
<div id="raster-subsetting" class="section level3">
<h3><span class="header-section-number">3.3.1</span> Raster subsetting</h3>
<p>We can subset raster datasets with the help of <code>[</code> which accepts different types of input.</p>
<ul>
<li>row-column indexing</li>
<li>cell IDs</li>
<li>coordinates</li>
<li>another raster object</li>
</ul>
<p>The latter two represent already spatial subsetting (see next chapter). Here, we demonstrate the first two subsetting options in the two commands below. Both return the value of the top left pixel in the raster object <code>elev</code> (results not shown):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># row 1, column 1</span>
elev[<span class="dv">1</span>, <span class="dv">1</span>]
<span class="co"># cell ID 1</span>
elev[<span class="dv">1</span>]</code></pre></div>
<p>To extract all values or complete rows, you can use <code>values()</code> and <code>getValues()</code> In case you apply subsetting to a raster stack or brick, this will return the cell value(s) for each single layer. For example, <code>stack(elev, grain)[1]</code> returns a matrix with one row and two columns - one for each layer. In this example we have used cell ID subsetting, of course, you can also use row-column or coordinate indexing. On the other hand, the <code>raster::subset()</code> command lets you extract a specific or several layers from a raster stack or brick. For the same operation, you can also use the <code>[[</code> operator. If you only want to extract a single layer, you might also use the <code>$</code> operator.</p>
<p>To modify a single cell value, we overwrite existing values with the help of subsetting operations (see above). For instance, let us replace the upper left cell of <code>elev</code>, which is 1, by 0:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">elev[<span class="dv">1</span>, <span class="dv">1</span>] =<span class="st"> </span><span class="dv">0</span>
elev[]
<span class="co">#&gt;  [1]  0  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23</span>
<span class="co">#&gt; [24] 24 25 26 27 28 29 30 31 32 33 34 35 36</span></code></pre></div>
<p>Leaving the square brackets empty is a shortcut version of <code>values()</code> for retrieving all values of a raster. Of course, one can use indexing to modify multiple cells or even blocks.</p>
</div>
<div id="summarizing-raster-objects" class="section level3">
<h3><span class="header-section-number">3.3.2</span> Summarizing raster objects</h3>
<p>In R we can easily derive descriptive statistics for entire rasters. Printing the raster object to the console already returns the minimum and maximum values of a raster. You can also use the <code>summary()</code> function for the most common descriptive statistics (minimum, maximum, interquartile range and number of <code>NA</code>s). If we are interested in further summary operations such as the standard deviation (see below) or if we want to define our own summary functions, we can do so with the <code>cellStats</code> command.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cellStats</span>(elev, sd)</code></pre></div>
<p>Note: if you provide the <code>summary()</code> and <code>cellStats()</code> functions with a raster stack or brick object, they will summarize each layer separately. Try <code>summary(brick(elev, grain))</code>. Nothing stops us from visualizing descriptive raster statistics. We can manually retrieving raster values with the help of the <code>values()</code> and <code>getValues()</code> function, and putting their output into any <code>plot()</code> function we like. Or we can make use of the <code>boxplot()</code>, <code>density()</code>, <code>hist()</code> and <code>pairs()</code> methods for raster objects.</p>
<p>Descriptive raster statistics belong to the so-called global raster operations. These and other typical raster processing operations are part of the map algebra scheme which we will get to know better in the next chapter.</p>
<div class="rmdnote">
<p>
Some function names clash between packages (e.g., <code>select</code>, as discussed in a previous note). In addition to not loading packages by referring to functions verbosely (e.g., <code>dplyr::select()</code>) another way to prevent function names clashes is by unloading the offending package with <code>detach()</code>. The following command, for example, unloads the <strong>raster</strong> package (this can also be done in the <em>package</em> tab in the right-bottom pane in RStudio): <code>detach(“package:raster”, unload = TRUE, force = TRUE)</code>. The <code>force</code> argument makes sure that the package will be detached even if other packages depend on it. This, however, may lead to a restricted usability of packages depending on the detached package, and is therefore not recommended.
</p>
</div>
</div>
</div>
<div id="exercises-2" class="section level2">
<h2><span class="header-section-number">3.4</span> Exercises</h2>
<p>For these exercises we will use the <code>us_states</code> and <code>us_states_df</code> datasets from the <strong>spData</strong> package:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(spData)
<span class="kw">data</span>(us_states)
<span class="kw">data</span>(us_states_df)</code></pre></div>
<p><code>us_states</code> is a spatial object (of class <code>sf</code>), containing geometry and a few attributes (including name, region, area, and population) of states within the contiguous United States. <code>us_states_df</code> is a data frame (of class <code>data.frame</code>) containing the name and additional variables (including median income and poverty level, for years 2010 and 2015) of US states, including Alaska, Hawaii and Puerto Rico. The data comes from the US Census Bureau, and is documented in <code>?us_states</code> and <code>?us_states_df</code>.</p>
<!-- Attribute subsetting -->
<ol style="list-style-type: decimal">
<li>Create a new object called <code>us_states_name</code> that contains only the <code>NAME</code> column from the <code>us_states</code> object. What is the class of the new object? <!--why there is a "sf" part? --></li>
<li>Select columns from the <code>us_states</code> object which contain population data. Obtain the same result using a different command (bonus: try to find three ways of obtaining the same result). Hint: try to use helper functions, such as <code>contains</code> or <code>starts_with</code> from <strong>dplyr</strong> (see <code>?contains</code>).</li>
<li>Find all states with the following characteristics (bonus find <em>and</em> plot them):</li>
</ol>
<ul>
<li>belong to the Midwest region.</li>
<li>belong to the West region, have an area below 250,000 km<sup>2</sup> <em>and</em> in 2015 a population greater than 5,000,000 residents (hint: you may need to use the function <code>units::set_units()</code> or <code>as.numeric()</code>).</li>
<li>belong to the South region, had an area larger than 150,000 km<sup>2</sup> or a total population in 2015 larger than 7,000,000 residents. <!-- Attribute aggregation --></li>
</ul>
<ol start="4" style="list-style-type: decimal">
<li>What was the total population in 2015 in the <code>us_states</code> dataset? What was the minimum and maximum total population in 2015?</li>
<li>How many states are there in each region?</li>
<li>What was the minimum and maximum total population in 2015 in each region? What was the total population in 2015 in each region? <!-- Attribute joining --></li>
<li>Add variables from <code>us_states_df</code> to <code>us_states</code>, and create a new object called <code>us_states_stats</code>. What function did you use and why? Which variable is the key in both datasets? What is the class of the new object?</li>
<li><code>us_states_df</code> has two more variables than <code>us_states</code>. How you can find them? (hint: try to use the <code>dplyr::anti_join</code> function) <!-- Attribute creation --></li>
<li>What was the population density in 2015 in each state? What was the population density in 2010 in each state?</li>
<li>How much has population density changed between 2010 and 2015 in each state? Calculate the change in percentages and map them.</li>
<li>Change the columns names in <code>us_states</code> to lowercase. (Hint: helper functions - <code>tolower()</code> and <code>colnames()</code> may help). <!-- Mixed exercises --> <!-- combination of use of select, mutate, group_by, summarize, etc  --></li>
<li>Using <code>us_states</code> and <code>us_states_df</code> create a new object called <code>us_states_sel</code>. The new object should have only two variables - <code>median_income_15</code> and <code>geometry</code>. Change the name of the <code>median_income_15</code> column to <code>Income</code>.</li>
<li>Calculate the change in median income between 2010 and 2015 for each state. Bonus: what was the minimum, average and maximum median income in 2015 for each region? What is the region with the largest increase of the median income? <!-- Raster exercises --></li>
<li>Create a raster from scratch with nine rows and columns and a resolution of 0.5 decimal degrees (WGS84). Fill it with random numbers. Extract the values of the four corner cells.</li>
<li>What is the most common class of our example raster <code>grain</code> (hint: <code>modal()</code>)?</li>
<li>Plot the histogram and the boxplot of the <code>data(dem, package = &quot;RQGIS&quot;)</code> raster.</li>
<li>Now attach also <code>data(ndvi, package = &quot;RQGIS&quot;)</code>. Create a raster stack using <code>dem</code> and <code>ndvi</code>, and make a <code>pairs()</code> plot</li>
</ol>

</div>
</div>
<h3> References</h3>
<div id="refs" class="references">
<div id="ref-grolemund_r_2016">
<p>Grolemund, Garrett, and Hadley Wickham. 2016. <em>R for Data Science</em>. 1 edition. O’Reilly Media.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="19">
<li id="fn19"><p>Unlike objects of class <code>Spatial</code> of the <strong>sp</strong> package, <code>sf</code> objects are also compatible with the <strong>tidyverse</strong> packages <strong>dplyr</strong> and <strong>ggplot2</strong>. The former provides fast and powerful functions for data manipulation (see <a href="https://csgillespie.github.io/efficientR/data-carpentry.html#data-processing-with-data.table">Section 6.7</a> of <span class="citation">Gillespie and Lovelace (<a href="#ref-gillespie_efficient_2016">2016</a>)</span>), and the latter provides powerful plotting capabilities.<a href="attr.html#fnref19">↩</a></p></li>
<li id="fn20"><p>If you want <strong>dplyr</strong> to return a vector, use <code>pull</code>.<a href="attr.html#fnref20">↩</a></p></li>
<li id="fn21"><p>Note that <code>st_geometry(world_st) = NULL</code> also works to remove the geometry from <code>world</code> but overwrites the original object.<a href="attr.html#fnref21">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="spatial-class.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="spatial-data-operations.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/Robinlovelace/geocompr/edit/master/03-attribute-operations.Rmd",
"text": "Edit"
},
"download": null,
"toc": {
"collapse": "section"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
