[
["index.html", "Geocomputation with R Welcome Development Reproducibility Acknowledgements", " Geocomputation with R Robin Lovelace Jakub Nowosad 2017-06-01 Welcome Welcome to geocompr the website of our forthcoming book with CRC Press. Development Inspired by the bookdown R package we are developing this book in the open. We decided to make the book open source to encourage contributions, ensure reproducibility and provide access to the material as it evolves. We’re developing the book in 3 main phases. We’re in phase 1 and focussed on the first 5 main chapters, which we aim to be complete by September. Drafts of other chapters will be added to this website as they project progresses. The latest version is hosted at robinlovelace.net/geocompr. This website is kept up-to-date thanks to Travis, a continuous integration (CI) service. Travis automatically rebuilds the book and finds bugs by reporting the ‘build status’ after every update. Currently the build is: The version of the book you are reading now was built on 2017-06-01 and was built on Travis. bookdown makes editing a book as easy as editing a wiki. To do so, just click on the ‘edit me’ icon highlighted in the image below. Which-ever chapter you are looking at, this will take you to the source R Markdown file hosted on GitHub. If you have a GitHub account, you’ll be able to make changes there and submit a pull request. If you do not, it’s time to sign-up! To raise an issue about the book’s content (e.g. code not running) or make a feature request, check-out the issue tracker. Reproducibility To reproduce the book, you need a recent version of R and up-to-date packages. The following code should install the required packages: if(!require(devtools)) { install.packages(&quot;devtools&quot;) } devtools::install_github(&quot;robinlovelace/geocompr&quot;) devtools::install_github(&quot;nowosad/spData&quot;) To build the book locally, clone or download the repo and run the following line from the project’s root directory: bookdown::render_book(&quot;index.Rmd&quot;) # to build the book browseURL(&quot;_book/index.html&quot;) # to view it For further details see the book’s GitHub page at Robinlovelace/geocompr. Acknowledgements "],
["intro.html", "1 Introduction 1.1 Why Geocomputation with R? 1.2 R’s spatial ecosystem", " 1 Introduction This book exists at the intersection between Geography and R (Figure 1.1). Suggested titles were Geography with R and R for GIS, each of which has advantages. The former conveys the message that it’s not just about spatial data: non-spatial attribute data are inevitably interwoven with geometry data, and Geography is about more than where something is on the map. The latter option communicates that this is a book about using R as a Geographic Information System (GIS), to perform spatial operations on geographic data (Bivand, Pebesma, and Gómez-Rubio 2013). However, the term GIS has some negative connotations (see Table 1.1) and fails to communicate one of R’s greatest strengths: its unparalleled ability to seamlessly switch between geographic and non-geographic data processing, modeling and visualization tasks. Figure 1.1: Venn diagram of the intersection between Geography and R. The title was chosen because this book is about more than routine spatial data processing, something that is well captured by the term geocomputation. What defines geocomputation as a development on previous work is the “creative and experimental use of GIS that it entails” (Longley et al. 1998). With geocomputation geographic data can be used in new ways. Another advantage of geocomputation that it conveys the centrality of the concept of algorithms (which can be implemented in R functions) to advanced geographical research. Geocomputation is a relatively young field1 but methods published under the geocomputational banner have influenced the direction of geographical research, as we will see in subsequent chapters. Algorithms are powerful tools that can become highly complex. However, all algorithms are composed of smaller parts. By teaching these foundations we aim to empower you. Creating your own solutions to geographic data problems can feel like breaking free from the metaphorical ‘glass ceiling’ imposed by GUI-based proprietary geographic information systems (see Table 1.1 for a definition of GUI). While embracing recent developments in the field, we also wanted to pay respects the wider field of Geography, and its 2000 year history (Roller 2010), of which geocomputation is a part. Geography has played an important role in explaining and influencing humanity’s relationship with the natural world and this book aims to be a part of the ‘Geographic tradition’. Geocomputation in this book therefore means more than simply analyzing geographic data on a computer. It’s about trying to make research which involves making geographic data more reproducible, scientific and socially beneficial. This book is also part of the movement towards Geographic Data Science (GDS) which differs from GIS in several ways, some of which are outlined in Table 1.1. Inspired by the emphasis of GDS research on reproducibility, this book aims teach how to do geocomputation rather than just think about it. Table 1.1: Differences in emphasis between the fields of Geographic Information Systems (GIS) and Geographic Data Science (GDS). Attribute GIS GDS Home disciplines Geography Geography, Computing, Statistics Software focus Graphical User Interface Code Reproduciblility Minimal Maximal 1.1 Why Geocomputation with R? In this book we treat R as a ‘tool for the trade’. Early geographers used a variety of tools including rulers, compasses and sextants to advance knowledge about the world. It is important to remember that while R is a powerful tool, especially when interfaced with other software such as GDAL and PostGIS, other tools may be better for certain tasks. R is characterised by its flexibility, enabling geographical software developers to extend it in multiple ways. A good example of this is support for generating interactive maps thanks to leaflet (Cheng, Karambelkar, and Xie 2017), which has been subsequently built-on by tmap and mapview (Appelhans et al. 2017; Tennekes 2017). These packages help overcome the criticism that R has “limited interactive [plotting] facilities” (Bivand, Pebesma, and Gómez-Rubio 2013). This is no longer true, as illustrated by the code below which generates Figure 1.2. library(leaflet) popup = c(&quot;Robin&quot;, &quot;Jakub&quot;) leaflet() %&gt;% addProviderTiles(&quot;NASAGIBS.ViirsEarthAtNight2012&quot;) %&gt;% addAwesomeMarkers(lng = c(-3, 23), lat = c(52, 53), popup = popup) Figure 1.2: World at night imagery from NASA overlaid by the authors’ approximate home locations to illustrate interactive mapping with R. It would be difficult to produce Figure 1.2 with only 4 lines of code in another language, let alone embed the results in an interactive html page (the interactive version can be viewed at robinlovelace.net/geocompr), illustrating R’s flexibility. R provides a stable language that should behave consistently across multiple computers, free of charge. The use of R code therefore enables teaching geocomputation with reference to reproducible examples such as that provided in 1.2 rather than abstract concepts. But before cracking-on with the action, a few introductory remarks are needed to explain the approach taken here and provide context. 1.2 R’s spatial ecosystem The most important recent evolution in R’s spatial ecosystem has without doubt been support for simple features thanks to the sf package (E. Pebesma 2017), described in Chapter 2. References "],
["spatial-class.html", "2 Simple features and plots Prerequisites 2.1 An introduction to Simple Features 2.2 Why Simple Features? 2.3 Basic map making 2.4 Vector data 2.5 Raster data", " 2 Simple features and plots Prerequisites 2.1 An introduction to Simple Features Simple Features is an open standard data model developed and endorsed by the Open Geospatial Consortium (OGC) to describe how features with geographical and non-geographical features should be represented. It is a hierarchical data model that simplifies geographic data by condensing the complex range of possible geographic forms (e.g., line, point, polygon, multipolygon forms) into a single geometry class. The R implementation of Simple Features is provided by the sf package (E. Pebesma 2017), which can be installed with the following command:2 install.packages(&quot;sf&quot;) sf incorporates the functionality of the 3 main packages of the sp paradigm (sp (E. Pebesma and Bivand 2016) for the class system, rgdal (Bivand, Keitt, and Rowlingson 2017) for reading and writing data, rgeos (Bivand and Rundel 2017) for spatial operations undertaken by GEOS) in a single, cohesive whole. This is well-documented in sf’s vignettes: vignette(&quot;sf1&quot;) # for an introduction to the package vignette(&quot;sf2&quot;) # for reading, writing and converting Simple Features vignette(&quot;sf3&quot;) # for manipulating Simple Features As the first vignette explains, simple feature objects in R are stored in a data frame, with geographic data occupying special column, a ‘list-column’. This column is usually named ‘geom’ or ‘geometry’. Let’s see how simple features in R work, with reference to world boundary data from the spData package: library(spData) class(world) In the above code spData silently loaded the world dataset (and many other spatial datasets - see nowosad/spData for a full list). The function class() tells us that the object is simultaneously of class data.frame and sf, central to the concept of simple features. Thus the object behaves in the same way as a data.frame, but it contains a special column called geom. This can be seen as the final column name of world: names(world) #&gt; [1] &quot;iso_a2&quot; &quot;name_long&quot; &quot;continent&quot; &quot;region_un&quot; &quot;subregion&quot; #&gt; [6] &quot;type&quot; &quot;area_km2&quot; &quot;pop&quot; &quot;lifeExp&quot; &quot;gdpPercap&quot; #&gt; [11] &quot;geom&quot; It is the contents of this modest-looking geom column, gives sf objects their spatial powers. It’s actually a list-column, containing all the coordinates needed to plot the result as a map using the plot() method, the results of which are presented in Figure 2.1. library(sf) # must be loaded to plot sf objects #&gt; Linking to GEOS 3.5.0, GDAL 2.1.0, proj.4 4.8.0 plot(world) #&gt; Warning: plotting the first 9 out of 10 attributes; use max.plot = 10 to #&gt; plot all Figure 2.1: A spatial plot of the world using the sf package, with a facet for each attribute. Note that instead of creating a single map, as most GIS programs would, the plot() command has created multiple maps, one for each variable in the world datasets. This behavior can be useful for exploring the spatial distribution of different variables and is discussed further in @(basic-map) below. Being able to treat spatial objects as regular data frames with spatial powers has many advantages, especially if you are already used to working with data frames. We explore such ‘attribute operations’ in Chapter 3. First, it’s worth taking a look at the basic behavior and contents of this simple feature object, which can usefully be thought of as a ’Spatial dataFrame). sf objects are easy to subset. The code below shows its first 2 rows and 3 columns. The output shows 2 major differences compared with a regular data.frame: the inclusion of additional geographic data (geometry type, dimension, bbox and CRS information - epsg (SRID), proj4string), and the presence of final geometry column: world[1:2, 1:3] #&gt; Simple feature collection with 2 features and 3 fields #&gt; geometry type: MULTIPOLYGON #&gt; dimension: XY #&gt; bbox: xmin: 11.6401 ymin: -17.93064 xmax: 75.15803 ymax: 38.48628 #&gt; epsg (SRID): 4326 #&gt; proj4string: +proj=longlat +datum=WGS84 +no_defs #&gt; iso_a2 name_long continent geom #&gt; 1 AF Afghanistan Asia MULTIPOLYGON(((61.210817091... #&gt; 2 AO Angola Africa MULTIPOLYGON(((16.326528354... All this may seem rather complex, especially for a class system that is supposed to be simple. However, there are good reasons for organizing things this way and using sf. 2.1.1 Exercises What does the summary of the geometry column tell us about the world dataset, in terms of: The geometry type? How many countries there are? The coordinate reference system (CRS)? 2.2 Why Simple Features? There are many advantages of sf over sp, including: Faster reading and writing of data (more than 10 times faster in some cases) Better plotting performance sf objects can be treated as dataframes in most operations sf functions can be combined using %&gt;% operator and works well with the tidyverse collection of R packages sf function names are relatively consistent and intuitive (all begin with st_) compared with the function names and syntax of the sp, rgdal and rgeos packages that it supersedes. A broader advantage is that simple features are so well supported by other software products, not least PostGIS, which has heavily influenced the design of sf. A disadvantage you should be aware of, however, is that sf is not feature complete and that it continues to evolve. The transition from sp to sf will likely take many years, and many spatial packages may never switch. Even if you discover spatial data with R through the sf package, it is still worth at least being aware of sp classes, even if you rarely use them for everyday geospatial tasks. Fortunately it is easy to translate between sp and sf using the as() function: library(sp) world_sp = as(object = world, Class = &quot;Spatial&quot;) 2.3 Basic map making Basic maps in sf can be created quickly with the base plot() function. Unlike sp, however, sf by default creates a faceted plot, one sub-plot for each variable, as illustrated in the left-hand image in Figure 2.2. plot(world[3:4]) plot(world[&quot;pop&quot;]) Figure 2.2: Plotting with sf, with multiple variables (left) and a single variable (right). As with sp, you can add layers to your maps created with plot(), with the argument add = TRUE.3 To illustrate this, and prepare for content covered in chapters 3 and 4 on attribute and spatial data operations, we will subset and combine countries in the world object, to create a single object that represents Asia: asia = world[world$continent == &quot;Asia&quot;, ] asia = st_union(asia) We can now plot the Asian continent over a map of the world. Note, however, that this only works if the initial plot has only 1 layer: plot(world[&quot;pop&quot;]) plot(asia, add = TRUE, col = &quot;red&quot;) This can be very useful for quickly checking the geographic correspondence between two or more layers: the plot() function is fast to execute and requires few lines of code, but does not create interactive maps with a wide range of options. For more advanced map making we recommend using a dedicated visualisation package such as tmap, ggplot2, mapview, or leaflet. 2.3.1 Challenge Using sf’s plot() command, create a map of Nigeria in context, like the one presented in figure 2.3. Hint: this used the lwd, main and col arguments of plot(). Bonus: make the country boundaries a dotted grey line. Hint: border is an additional argument of plot() for sf objects. Figure 2.3: Map of Nigeria in context illustrating sf’s plotting capabilities 2.3.2 Further work sf makes R data objects more closely aligned to the data model used in GDAL and GEOS, in theory making spatial data operations faster. The work here provides a taster of the way that sf operates but there is much more to learn (see Chapter 4). There is a wealth of information that is available in the package’s vignettes: these are highly recommended. As a final exercise, we’ll see how to do a spatial overlay in sf by first converting the countries of the world into centroids and then subsetting those in Asia. Because sf’s plot() builds on the base plot() function, you have access to all the base plotting options developed for base plotting. If you are accustomed to base plotting, this will be useful, as illustrated by the variable circle sizes generated by the cex argument in Figure 2.4, which was generated using the code below. world_centroids = st_centroid(world) plot(world[&quot;continent&quot;]) plot(world_centroids, add = TRUE, cex = world$pop / 1e8, lwd = 3) Figure 2.4: Centroids representing country population, diameter being proportional to population. Note: another way of acheiving the same result is with a GEOS function for identifying spatial overlay, which we’ll cover in more datail in Chapter 4. sel_asia = st_intersects(world_centroids, asia, sparse = FALSE) #&gt; although coordinates are longitude/latitude, it is assumed that they are planar summary(sel_asia) #&gt; V1 #&gt; Mode :logical #&gt; FALSE:134 #&gt; TRUE :43 2.3.3 Exercises What does the lwd argument do in the plot() code that generates Figure 2.4. Perform the same operations and map making for another continent of your choice. Bonus: Download some global geographic data and add attribute variables assigning them to the continents of the world. 2.4 Vector data 2.5 Raster data References "],
["attr.html", "3 Attribute data operations Prerequisites 3.1 Introduction 3.2 Base vs data.table vs dplyr 3.3 Attribute subsetting 3.4 Attribute data aggregation 3.5 Attribute data joining 3.6 Attribute data creation 3.7 Removing spatial information", " 3 Attribute data operations Prerequisites This chapter requires tidyverse, sf, units, and spData packages: library(sf) library(tidyverse) library(units) You must have loaded the world and worldbank_df data from the spData package: library(spData) data(&quot;world&quot;) data(&quot;worldbank_df&quot;) 3.1 Introduction Attribute data is non-geographic information associated with geographical data. In the context of simple features, introduced in the previous chapter, this means a tabular data joined onto the geometry variables of sf objects. This structure enables multiple columns to represent a range of attributes for thousands of features (one row per feature). There is a strong overlap between geographical and non-geographical operations: non-spatial subset, aggregate and join operations each have their geographical equivalents. For this reason this chapter provides the foundation for next (chapter 4). The two chapters share the same structure and input data; it is recommended that they are read together. The non-spatial versions of these methods are common and easy to understand with R, so they are covered first. The methods are largely cross-transferable to the trickier tasks of spatial data operations, so pay attention! Simple features defined by the sf package make working with attribute data easy because objects of class sf are data frames. This means that all the accumulated wisdom and functions accumulated in the R community for handling data frames can be applied to the non-geographic aspects of data, as illustrated below for the world object: class(world) #&gt; [1] &quot;sf&quot; &quot;data.frame&quot; This ‘world’ dataset contains 63 non-geographical variables (and one geometry column) with data for almost 200 countries, as can be ascertained using base functions for working with tabular data: dim(world) # it is a 2 dimensional object, with rows and columns #&gt; [1] 177 11 nrow(world) # how many rows? #&gt; [1] 177 ncol(world) # how many columns? #&gt; [1] 11 Extracting the attribute data of an sf object is the same as removing the geometry column: world_df = world st_geometry(world_df) = NULL class(world_df) #&gt; [1] &quot;data.frame&quot; This can be useful if the geometry column causes problem, e.g. by occupying large amounts of RAM. However, for most cases there is no harm in keeping the geometry column, as data frame operations on sf will only act on the attribute data. For this reason, being good at working with attribute data in geographic data is the same being proficient at handling data frames in R. For many applications, the most effective and intuitive way to work with data frames is with the dplyr package. 3.2 Base vs data.table vs dplyr Simple feature objects of class sf behave exactly the same as data.frame objects for most base R operations. Unlike objects of class Spatial defined by the sp package, sf objects are also compatible with dplyr and data.table packages. This is an advantage because they provide fast functions for data manipulation. Which method you use is largely a matter of preference. In this chapter the focus is largely on dplyr because of it’s intuitive function names and its ability to perform multiple chained operations using the pipe operator. The important thing is that you select a data processing paradigm of choice, and master it. 3.3 Attribute subsetting world[1:6, ] # subset rows world[, 1:3] # subset columns After each operation, the geometry column is preserved. dplyr makes working with data frames easier and is compatible with sf objects, after the package has been loaded: The select() function, for example, can be used to both subset and renames columns in a single line, for example: world_orig = world # create copy of world dataset for future reference world1 = select(world_orig, name_long, continent, population = pop) head(world1, n = 2) #&gt; Simple feature collection with 2 features and 3 fields #&gt; geometry type: MULTIPOLYGON #&gt; dimension: XY #&gt; bbox: xmin: 11.6401 ymin: -17.93064 xmax: 75.15803 ymax: 38.48628 #&gt; epsg (SRID): 4326 #&gt; proj4string: +proj=longlat +datum=WGS84 +no_defs #&gt; name_long continent population geom #&gt; 1 Afghanistan Asia 31627506 MULTIPOLYGON(((61.210817091... #&gt; 2 Angola Africa 24227524 MULTIPOLYGON(((16.326528354... This is more concises than the base R equivalent (which saves the result as an object called world2 to avoid overriding the world dataset created previously): world2 = world_orig[c(&quot;name_long&quot;, &quot;continent&quot;, &quot;pop&quot;)] # subset columns by name names(world2)[3] = &quot;population&quot; # rename column manually The pipe operator (%&gt;%), which passes the output of one function into the first argument of the next function, is commonly used in dplyr data analysis workflows. This works because the fundamental dplyr functions (or ‘verbs’, like select()) all take a data frame object in and spit a data frame object out. Combining many functions together with pipes is called chaining or piping. The advantage over base R for complex data processing operations is that this approach prevents nested functions and is easy to read because there is a clear order and modularity to the work (a piped command can be commented out, for example). The example below shows yet another way of creating the renamed world dataset, using the pipe operator: world3 = world_orig %&gt;% select(name_long, continent) The pipe operator can be used for many data processing tasks with attribute data: # todo - describe these: ==, !=, &gt;, &gt;=, &lt;, &lt;=, &amp;, | # Filtering attribute data with dplyr world_few_rows = world %&gt;% filter(pop &gt; 1e9) head(world_few_rows) #&gt; Simple feature collection with 2 features and 10 fields #&gt; geometry type: MULTIPOLYGON #&gt; dimension: XY #&gt; bbox: xmin: 68.17665 ymin: 7.965535 xmax: 135.0263 ymax: 53.4588 #&gt; epsg (SRID): 4326 #&gt; proj4string: +proj=longlat +datum=WGS84 +no_defs #&gt; iso_a2 name_long continent region_un subregion type #&gt; 1 CN China Asia Asia Eastern Asia Country #&gt; 2 IN India Asia Asia Southern Asia Sovereign country #&gt; area_km2 pop lifeExp gdpPercap geom #&gt; 1 9409832 1.36e+09 75.8 12759 MULTIPOLYGON(((110.33918786... #&gt; 2 3142892 1.30e+09 68.0 5392 MULTIPOLYGON(((77.837450799... This is equivalent to the following base R code (note NAs are forbidden for subsetting): # subsetting simple feature rows by values world$pop[is.na(world$pop)] = 0 world_few_rows = world[world$pop &gt; 1e9,] 3.4 Attribute data aggregation # data summary (not shown) summary(world) # data summary by groups (not shown) world_continents = world %&gt;% group_by(continent) %&gt;% summarise(continent_pop = sum(pop, na.rm = TRUE), country_n = n()) world_continents # sort variables ## by name world_continents %&gt;% arrange(continent) #&gt; Simple feature collection with 8 features and 3 fields #&gt; geometry type: GEOMETRY #&gt; dimension: XY #&gt; bbox: xmin: -180 ymin: -90 xmax: 180 ymax: 83.64513 #&gt; epsg (SRID): 4326 #&gt; proj4string: +proj=longlat +datum=WGS84 +no_defs #&gt; # A tibble: 8 x 4 #&gt; continent continent_pop country_n geom #&gt; &lt;fctr&gt; &lt;dbl&gt; &lt;int&gt; &lt;simple_feature&gt; #&gt; 1 Africa 1.15e+09 51 &lt;MULTIPOLYGON...&gt; #&gt; 2 Antarctica 0.00e+00 1 &lt;MULTIPOLYGON...&gt; #&gt; 3 Asia 4.31e+09 47 &lt;MULTIPOLYGON...&gt; #&gt; 4 Europe 7.39e+08 39 &lt;MULTIPOLYGON...&gt; #&gt; # ... with 4 more rows ## by population (in descending order) world_continents %&gt;% arrange(-continent_pop) #&gt; Simple feature collection with 8 features and 3 fields #&gt; geometry type: GEOMETRY #&gt; dimension: XY #&gt; bbox: xmin: -180 ymin: -90 xmax: 180 ymax: 83.64513 #&gt; epsg (SRID): 4326 #&gt; proj4string: +proj=longlat +datum=WGS84 +no_defs #&gt; # A tibble: 8 x 4 #&gt; continent continent_pop country_n geom #&gt; &lt;fctr&gt; &lt;dbl&gt; &lt;int&gt; &lt;simple_feature&gt; #&gt; 1 Asia 4.31e+09 47 &lt;MULTIPOLYGON...&gt; #&gt; 2 Africa 1.15e+09 51 &lt;MULTIPOLYGON...&gt; #&gt; 3 Europe 7.39e+08 39 &lt;MULTIPOLYGON...&gt; #&gt; 4 North America 5.65e+08 18 &lt;MULTIPOLYGON...&gt; #&gt; # ... with 4 more rows 3.5 Attribute data joining 3.6 Attribute data creation 3.7 Removing spatial information Most of the function from sf package do not drop a geometry column. To extract a data frame st_geometry() or st_set_geometry() function can be used. world_st = world st_geometry(world_st) = NULL class(world_st) #&gt; [1] &quot;data.frame&quot; # OR world_st2 = world world_st2 = world_st2 %&gt;% st_set_geometry(NULL) class(world_st2) #&gt; [1] &quot;data.frame&quot; "],
["spatial-data-operations.html", "4 Spatial data operations Prerequisites 4.1 Introduction 4.2 Attribute subsetting 4.3 Attribute data aggregation 4.4 Attribute data joining 4.5 Attribute data creation", " 4 Spatial data operations Prerequisites This chapter requires tidyverse, sf, units, and spData packages: library(sf) library(tidyverse) library(units) You must have loaded the world data from the spData package: library(spData) 4.1 Introduction 4.2 Attribute subsetting 4.3 Attribute data aggregation 4.4 Attribute data joining 4.5 Attribute data creation # add a new column world$area = set_units(st_area(world), value = km^2) world$pop_density = world$pop / world$area # OR world = world %&gt;% mutate(area = set_units(st_area(.), value = km^2)) %&gt;% mutate(pop_density = pop / area) Note that this has created a attributes for the area and population density variables: attributes(world$area) #&gt; $units #&gt; $numerator #&gt; [1] &quot;km&quot; &quot;km&quot; #&gt; #&gt; $denominator #&gt; character(0) #&gt; #&gt; attr(,&quot;class&quot;) #&gt; [1] &quot;symbolic_units&quot; #&gt; #&gt; $class #&gt; [1] &quot;units&quot; attributes(world$pop_density) #&gt; $units #&gt; $numerator #&gt; character(0) #&gt; #&gt; $denominator #&gt; [1] &quot;km&quot; &quot;km&quot; #&gt; #&gt; attr(,&quot;class&quot;) #&gt; [1] &quot;symbolic_units&quot; #&gt; #&gt; $class #&gt; [1] &quot;units&quot; These can be set to NULL as follows: attributes(world$area) = NULL attributes(world$pop_density) = NULL "],
["read-write.html", "5 Geographic data I/O 5.1 Data Input (I) 5.2 Data output (O) 5.3 File formats 5.4 Visual outputs 5.5 Exercises", " 5 Geographic data I/O The previous chapters introduced this book and provided an overview of spatial data classes in R, with a focus on simple features. This chapter is about getting spatial data onto your computer and then, perhaps after processing it with techniques described in this book, back out to the world. We include a section (5.4) on visualization because outputting data in a human (not just computer) readable enables non-programmers to benefit from your work. If your aim is to use geocomputation to improve the world, e.g. by encouraging evidence-based policies, this final stage is vital. I/O is short for “input/output” which means, in plain English, “reading and writing data”. We use the acronym instead of plain English not to confuse you or to make chapter names short, but because that’s the term used in computer science and it is useful to think of data import and export from a computing perspective.4 5.1 Data Input (I) To efficiently read data into R, it helps to have an understanding of what happens ‘under the hood’. Executing commands such as sf::st_read (the main function we use for loading spatial data, from the sf package) or readr::read_csv silently sets-off a chain of events that loads spatial objects. “Loading” in this context means loading the data into R or, more precisely, assigning objects to your workspace, stored in RAM accessible from the .GlobalEnv of your current R session. Spatial data comes in a wide variety of file formats, and sf is adept at handling them, via the command st_read. This function uses GDAL behind the scenes, enabling a very wide range of spatial data formats to be imported. The first arguement of st_read is file, which should be a text string or an object containing a single text string: library(sf) #&gt; Linking to GEOS 3.5.0, GDAL 2.1.0, proj.4 4.8.0 f = system.file(&quot;shapes/world.gpkg&quot;, package = &quot;spData&quot;) world = st_read(f) #&gt; Reading layer `wrld.gpkg&#39; from data source `/home/travis/R/Library/spData/shapes/world.gpkg&#39; using driver `GPKG&#39; #&gt; converted into: MULTIPOLYGON #&gt; Simple feature collection with 177 features and 10 fields #&gt; geometry type: MULTIPOLYGON #&gt; dimension: XY #&gt; bbox: xmin: -180 ymin: -90 xmax: 180 ymax: 83.64513 #&gt; epsg (SRID): 4326 #&gt; proj4string: +proj=longlat +datum=WGS84 +no_defs Tip: read_sf() and write_sf() can be used as easy-to-remember alternatives to st_read() and st_write(). Remember they hide information about the data source and overwrite existing data, though.. A major advantage of sf is that it is fast. To demonstrate this, we will use a function to compare st_read with it’s sp equivalent, rgdal::readOGR: bench_read = function(file, n) { m = microbenchmark(times = n, rgdal::readOGR(f), st_read(f) ) mean(m$time[1:n]) / mean(m$time[(n + 1):(n * 2)]) } This function takes as arguments an input file (file) and a number of times to run each command (n) and returns how many times faster st_read() is than readOGR(). Let’s run the benchmark for the world.gpkg file represented by the object f: We as illustrated in the benchmark below: library(microbenchmark) read_world_gpkg = bench_read(file = f, n = 5) read_world_gpkg #&gt; [1] 2.26 The results demonstrate that sf was around 2 times faster than rgdal at reading-in the world countries shapefile. The relative performance of st_read() compared with other functions will vary depending on file format and the nature of the data. To illustrate this point, we performed the same operation on a geojson file and found a greater speed saving: f = system.file(&quot;shapes/lnd.geojson&quot;, package = &quot;spData&quot;) read_lnd_geojson = bench_read(file = f, n = 5) read_lnd_geojson #&gt; [1] 3.07 In this case sf was around 3 times faster than rgdal. The full range of file-types supported by sf is reported by st_drivers(), the first 2 of which are shown below: sf_drivers = st_drivers() head(sf_drivers, n = 2) #&gt; name long_name write copy is_raster is_vector #&gt; PCIDSK PCIDSK PCIDSK Database File TRUE FALSE TRUE TRUE #&gt; netCDF netCDF Network Common Data Format TRUE TRUE TRUE TRUE 5.2 Data output (O) st_write(obj = world, dsn = &quot;world.gpkg&quot;) #&gt; Writing layer `world.gpkg&#39; to data source `world.gpkg&#39; using driver `GPKG&#39; #&gt; features: 177 #&gt; fields: 10 #&gt; geometry type: Multi Polygon Note: if you try write to the same data source again will fail. This is demonstrated in the code below for a modified version of the world in which the population doubles in all countries (don’t worry about the dplyr code for now, this is covered in Chapter 3): world_mod = dplyr::mutate(world, pop = pop * 2) #&gt; [1] TRUE st_write(obj = world_mod, dsn = &quot;world.gpkg&quot;) ## GDAL Error 1: Layer world.gpkg already exists, CreateLayer failed. ## Use the layer creation option OVERWRITE=YES to replace it. The error message provides some information about why it failed, some of which is provided in the comments. It is an issue at the GDAL level. This is clear from the statement GDAL Error 1. A further clue is provided by suggestion to use OVERWRITE=YES: this is not an option in st_write, but can be added with the argument layer_options: st_write(obj = world_mod, dsn = &quot;world.gpkg&quot;, layer_options = &quot;OVERWRITE=YES&quot;) Another solution to this issue is to use the argument delete_layer that deletes the previous layers in the data source before attempting to write (note there is also a delete_dsn argument). Setting this argument to TRUE makes the rewrite operation work: st_write(obj = world_mod, dsn = &quot;world.gpkg&quot;, delete_layer = TRUE) #&gt; Deleting layer `world.gpkg&#39; using driver `GPKG&#39; #&gt; Updating layer `world.gpkg&#39; to data source `/home/travis/build/Robinlovelace/geocompr/world.gpkg&#39; using driver `GPKG&#39; #&gt; features: 177 #&gt; fields: 10 #&gt; geometry type: Multi Polygon This can also be done with the function write_sf(), which is equivalent to (technically an alias for) st_write(), except that it has delete_layer = TRUE and quiet = TRUE by default. This enables spatial data to be overwritten more concisely and with less output going to screen: #&gt; [1] TRUE write_sf(obj = world_mod, dsn = &quot;world.gpkg&quot;) A blunter way to update file-based geographic data sources such as .gpkg files is to simply delete them. This is not generally recommended, as it will not work for multi-file data sources such as .shp files: file.remove(&quot;world.gpkg&quot;) #&gt; [1] TRUE The counterpart of st_read() is st_write(). This allows writing to a range of geographic vector file types, including the common formats .geojson, .shp and .gpkg. st_read() will decide which driver to use automatically, based on the file name, as illustrated in the benchmark below demonstrating write speeds for each format. system.time(st_write(world, &quot;world.geojson&quot;, quiet = TRUE)) #&gt; user system elapsed #&gt; 0.068 0.000 0.066 system.time(st_write(world, &quot;world.shp&quot;, quiet = TRUE)) #&gt; user system elapsed #&gt; 0.008 0.004 0.012 system.time(st_write(world, &quot;world.gpkg&quot;, quiet = TRUE)) #&gt; user system elapsed #&gt; 0.016 0.012 0.028 5.3 File formats 5.4 Visual outputs 5.5 Exercises Name three differences between write_sf() and the more well-known function st_write(). What are the default arguments of read_sf() and write_sf() that enable two of these differences? Concepts such as computational efficiency, hard disk space and ‘idempotence’ are useful when thinking about reading and writing geographic datasets, which can become large and difficult to handle. Loading/saving data is yet another way of saying the same thing.↩ "],
["references.html", "6 References", " 6 References "]
]
